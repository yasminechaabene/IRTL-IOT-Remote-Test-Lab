{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events');\n\nvar MessageStream = require('./message_stream');\n\nvar MongoError = require('../core/error').MongoError;\n\nvar MongoNetworkError = require('../core/error').MongoNetworkError;\n\nvar MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\n\nvar CommandResult = require('../core/connection/command_result');\n\nvar StreamDescription = require('./stream_description').StreamDescription;\n\nvar wp = require('../core/wireprotocol');\n\nvar apm = require('../core/connection/apm');\n\nvar updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\n\nvar uuidV4 = require('../core/utils').uuidV4;\n\nvar kStream = Symbol('stream');\nvar kQueue = Symbol('queue');\nvar kMessageStream = Symbol('messageStream');\nvar kGeneration = Symbol('generation');\nvar kLastUseTime = Symbol('lastUseTime');\nvar kClusterTime = Symbol('clusterTime');\nvar kDescription = Symbol('description');\nvar kIsMaster = Symbol('ismaster');\nvar kAutoEncrypter = Symbol('autoEncrypter');\n\nvar Connection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  function Connection(stream, options) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this, options));\n    _this.id = options.id;\n    _this.address = streamIdentifier(stream);\n    _this.bson = options.bson;\n    _this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n    _this.monitorCommands = typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    _this.closed = false;\n    _this.destroyed = false;\n    _this[kDescription] = new StreamDescription(_this.address, options);\n    _this[kGeneration] = options.generation;\n    _this[kLastUseTime] = Date.now(); // retain a reference to an `AutoEncrypter` if present\n\n    if (options.autoEncrypter) {\n      _this[kAutoEncrypter] = options.autoEncrypter;\n    } // setup parser stream and message handling\n\n\n    _this[kQueue] = new Map();\n    _this[kMessageStream] = new MessageStream(options);\n\n    _this[kMessageStream].on('message', messageHandler(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this[kStream] = stream;\n    stream.on('error', function () {\n      /* ignore errors, listen to `close` instead */\n    });\n    stream.on('close', function () {\n      if (_this.closed) {\n        return;\n      }\n\n      _this.closed = true;\n\n      _this[kQueue].forEach(function (op) {\n        return op.cb(new MongoNetworkError(\"connection \".concat(_this.id, \" to \").concat(_this.address, \" closed\")));\n      });\n\n      _this[kQueue].clear();\n\n      _this.emit('close');\n    });\n    stream.on('timeout', function () {\n      if (_this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      _this.closed = true;\n\n      _this[kQueue].forEach(function (op) {\n        return op.cb(new MongoNetworkError(\"connection \".concat(_this.id, \" to \").concat(_this.address, \" timed out\")));\n      });\n\n      _this[kQueue].clear();\n\n      _this.emit('close');\n    }); // hook the message stream up to the passed in stream\n\n    stream.pipe(_this[kMessageStream]);\n\n    _this[kMessageStream].pipe(stream);\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"markAvailable\",\n    value: function markAvailable() {\n      this[kLastUseTime] = Date.now();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      var _this2 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = Object.assign({\n        force: false\n      }, options);\n\n      if (this[kStream] == null || this.destroyed) {\n        this.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      if (options.force) {\n        this[kStream].destroy();\n        this.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      this[kStream].end(function (err) {\n        _this2.destroyed = true;\n\n        if (typeof callback === 'function') {\n          callback(err);\n        }\n      });\n    } // Wire protocol methods\n\n  }, {\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n    }\n  }, {\n    key: \"query\",\n    value: function query(ns, cmd, cursorState, options, callback) {\n      wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n    }\n  }, {\n    key: \"getMore\",\n    value: function getMore(ns, cursorState, batchSize, options, callback) {\n      wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n    }\n  }, {\n    key: \"killCursors\",\n    value: function killCursors(ns, cursorState, callback) {\n      wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(ns, ops, options, callback) {\n      wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n    }\n  }, {\n    key: \"update\",\n    value: function update(ns, ops, options, callback) {\n      wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(ns, ops, options, callback) {\n      wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      return this[kDescription];\n    }\n  }, {\n    key: \"ismaster\",\n    get: function get() {\n      return this[kIsMaster];\n    } // the `connect` method stores the result of the handshake ismaster on the connection\n    ,\n    set: function set(response) {\n      this[kDescription].receiveResponse(response); // TODO: remove this, and only use the `StreamDescription` in the future\n\n      this[kIsMaster] = response;\n    }\n  }, {\n    key: \"generation\",\n    get: function get() {\n      return this[kGeneration] || 0;\n    }\n  }, {\n    key: \"idleTime\",\n    get: function get() {\n      return Date.now() - this[kLastUseTime];\n    }\n  }, {\n    key: \"clusterTime\",\n    get: function get() {\n      return this[kClusterTime];\n    }\n  }, {\n    key: \"stream\",\n    get: function get() {\n      return this[kStream];\n    }\n  }]);\n\n  return Connection;\n}(EventEmitter); /// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\n\n\nfunction makeServerTrampoline(connection) {\n  var server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: {\n        write: write.bind(connection),\n        isConnected: function isConnected() {\n          return true;\n        }\n      }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    var operationDescription = conn[kQueue].get(message.responseTo); // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    }\n\n    var callback = operationDescription.cb;\n\n    if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      var document = message.documents[0];\n      var session = operationDescription.session;\n\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    } // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n\n    callback(undefined, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return \"\".concat(stream.remoteAddress, \":\").concat(stream.remotePort);\n  }\n\n  return uuidV4().toString('hex');\n} // Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\n\n\nfunction write(command, options, callback) {\n  var _this3 = this;\n\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  var operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operationDescription.started = process.hrtime();\n\n    operationDescription.cb = function (err, reply) {\n      if (err) {\n        _this3.emit('commandFailed', new apm.CommandFailedEvent(_this3, command, err, operationDescription.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          _this3.emit('commandFailed', new apm.CommandFailedEvent(_this3, command, reply.result, operationDescription.started));\n        } else {\n          _this3.emit('commandSucceeded', new apm.CommandSucceededEvent(_this3, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection: Connection\n};","map":null,"metadata":{},"sourceType":"script"}