{"ast":null,"code":"'use strict'; // Implementation of OP_MSG spec:\n// https://github.com/mongodb/specifications/blob/master/source/message/OP_MSG.rst\n//\n// struct Section {\n//   uint8 payloadType;\n//   union payload {\n//       document  document; // payloadType == 0\n//       struct sequence { // payloadType == 1\n//           int32      size;\n//           cstring    identifier;\n//           document*  documents;\n//       };\n//   };\n// };\n// struct OP_MSG {\n//   struct MsgHeader {\n//       int32  messageLength;\n//       int32  requestID;\n//       int32  responseTo;\n//       int32  opCode = 2013;\n//   };\n//   uint32      flagBits;\n//   Section+    sections;\n//   [uint32     checksum;]\n// };\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar opcodes = require('../wireprotocol/shared').opcodes;\n\nvar databaseNamespace = require('../wireprotocol/shared').databaseNamespace;\n\nvar ReadPreference = require('../topologies/read_preference'); // Incrementing request id\n\n\nvar _requestId = 0; // Msg Flags\n\nvar OPTS_CHECKSUM_PRESENT = 1;\nvar OPTS_MORE_TO_COME = 2;\nvar OPTS_EXHAUST_ALLOWED = 1 << 16;\n\nvar Msg = /*#__PURE__*/function () {\n  function Msg(bson, ns, command, options) {\n    _classCallCheck(this, Msg);\n\n    // Basic options needed to be passed in\n    if (command == null) throw new Error('query must be specified for query'); // Basic options\n\n    this.bson = bson;\n    this.ns = ns;\n    this.command = command;\n    this.command.$db = databaseNamespace(ns);\n\n    if (options.readPreference && options.readPreference.mode !== ReadPreference.PRIMARY) {\n      this.command.$readPreference = options.readPreference.toJSON();\n    } // Ensure empty options\n\n\n    this.options = options || {}; // Additional options\n\n    this.requestId = options.requestId ? options.requestId : Msg.getRequestId(); // Serialization option\n\n    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16; // flags\n\n    this.checksumPresent = false;\n    this.moreToCome = options.moreToCome || false;\n    this.exhaustAllowed = typeof options.exhaustAllowed === 'boolean' ? options.exhaustAllowed : false;\n  }\n\n  _createClass(Msg, [{\n    key: \"toBin\",\n    value: function toBin() {\n      var buffers = [];\n      var flags = 0;\n\n      if (this.checksumPresent) {\n        flags |= OPTS_CHECKSUM_PRESENT;\n      }\n\n      if (this.moreToCome) {\n        flags |= OPTS_MORE_TO_COME;\n      }\n\n      if (this.exhaustAllowed) {\n        flags |= OPTS_EXHAUST_ALLOWED;\n      }\n\n      var header = Buffer.alloc(4 * 4 + // Header\n      4 // Flags\n      );\n      buffers.push(header);\n      var totalLength = header.length;\n      var command = this.command;\n      totalLength += this.makeDocumentSegment(buffers, command);\n      header.writeInt32LE(totalLength, 0); // messageLength\n\n      header.writeInt32LE(this.requestId, 4); // requestID\n\n      header.writeInt32LE(0, 8); // responseTo\n\n      header.writeInt32LE(opcodes.OP_MSG, 12); // opCode\n\n      header.writeUInt32LE(flags, 16); // flags\n\n      return buffers;\n    }\n  }, {\n    key: \"makeDocumentSegment\",\n    value: function makeDocumentSegment(buffers, document) {\n      var payloadTypeBuffer = Buffer.alloc(1);\n      payloadTypeBuffer[0] = 0;\n      var documentBuffer = this.serializeBson(document);\n      buffers.push(payloadTypeBuffer);\n      buffers.push(documentBuffer);\n      return payloadTypeBuffer.length + documentBuffer.length;\n    }\n  }, {\n    key: \"serializeBson\",\n    value: function serializeBson(document) {\n      return this.bson.serialize(document, {\n        checkKeys: this.checkKeys,\n        serializeFunctions: this.serializeFunctions,\n        ignoreUndefined: this.ignoreUndefined\n      });\n    }\n  }]);\n\n  return Msg;\n}();\n\nMsg.getRequestId = function () {\n  _requestId = _requestId + 1 & 0x7fffffff;\n  return _requestId;\n};\n\nvar BinMsg = /*#__PURE__*/function () {\n  function BinMsg(bson, message, msgHeader, msgBody, opts) {\n    _classCallCheck(this, BinMsg);\n\n    opts = opts || {\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false\n    };\n    this.parsed = false;\n    this.raw = message;\n    this.data = msgBody;\n    this.bson = bson;\n    this.opts = opts; // Read the message header\n\n    this.length = msgHeader.length;\n    this.requestId = msgHeader.requestId;\n    this.responseTo = msgHeader.responseTo;\n    this.opCode = msgHeader.opCode;\n    this.fromCompressed = msgHeader.fromCompressed; // Read response flags\n\n    this.responseFlags = msgBody.readInt32LE(0);\n    this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;\n    this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;\n    this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;\n    this.promoteLongs = typeof opts.promoteLongs === 'boolean' ? opts.promoteLongs : true;\n    this.promoteValues = typeof opts.promoteValues === 'boolean' ? opts.promoteValues : true;\n    this.promoteBuffers = typeof opts.promoteBuffers === 'boolean' ? opts.promoteBuffers : false;\n    this.documents = [];\n  }\n\n  _createClass(BinMsg, [{\n    key: \"isParsed\",\n    value: function isParsed() {\n      return this.parsed;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(options) {\n      // Don't parse again if not needed\n      if (this.parsed) return;\n      options = options || {};\n      this.index = 4; // Allow the return of raw documents instead of parsing\n\n      var raw = options.raw || false;\n      var documentsReturnedIn = options.documentsReturnedIn || null;\n      var promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : this.opts.promoteLongs;\n      var promoteValues = typeof options.promoteValues === 'boolean' ? options.promoteValues : this.opts.promoteValues;\n      var promoteBuffers = typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : this.opts.promoteBuffers; // Set up the options\n\n      var _options = {\n        promoteLongs: promoteLongs,\n        promoteValues: promoteValues,\n        promoteBuffers: promoteBuffers\n      };\n\n      while (this.index < this.data.length) {\n        var payloadType = this.data.readUInt8(this.index++);\n\n        if (payloadType === 1) {\n          console.error('TYPE 1');\n        } else if (payloadType === 0) {\n          var bsonSize = this.data.readUInt32LE(this.index);\n          var bin = this.data.slice(this.index, this.index + bsonSize);\n          this.documents.push(raw ? bin : this.bson.deserialize(bin, _options));\n          this.index += bsonSize;\n        }\n      }\n\n      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {\n        var fieldsAsRaw = {};\n        fieldsAsRaw[documentsReturnedIn] = true;\n        _options.fieldsAsRaw = fieldsAsRaw;\n        var doc = this.bson.deserialize(this.documents[0], _options);\n        this.documents = [doc];\n      }\n\n      this.parsed = true;\n    }\n  }]);\n\n  return BinMsg;\n}();\n\nmodule.exports = {\n  Msg: Msg,\n  BinMsg: BinMsg\n};","map":null,"metadata":{},"sourceType":"script"}