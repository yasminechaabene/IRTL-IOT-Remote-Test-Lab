{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar crypto = require('crypto');\n\nvar debugOptions = require('./utils').debugOptions;\n\nvar parseHeader = require('../wireprotocol/shared').parseHeader;\n\nvar decompress = require('../wireprotocol/compression').decompress;\n\nvar Response = require('./commands').Response;\n\nvar BinMsg = require('./msg').BinMsg;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar MongoError = require('../error').MongoError;\n\nvar Logger = require('./logger');\n\nvar OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nvar OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\n\nvar MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar _id = 0;\nvar DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nvar DEBUG_FIELDS = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nvar connectionAccountingSpy = undefined;\nvar connectionAccounting = false;\nvar _connections = {};\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\n\nvar Connection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  function Connection(socket, options) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this));\n    options = options || {};\n\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    _this.id = _id++;\n    _this.options = options;\n    _this.logger = Logger('Connection', options);\n    _this.bson = options.bson;\n    _this.tag = options.tag;\n    _this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n    _this.port = options.port || 27017;\n    _this.host = options.host || 'localhost';\n    _this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000; // These values are inspected directly in tests, but maybe not necessary to keep around\n\n    _this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    _this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n    _this.connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n\n    if (_this.keepAliveInitialDelay > _this.socketTimeout) {\n      _this.keepAliveInitialDelay = Math.round(_this.socketTimeout / 2);\n    } // Debug information\n\n\n    if (_this.logger.isDebug()) {\n      _this.logger.debug(\"creating connection \".concat(_this.id, \" with options [\").concat(JSON.stringify(debugOptions(DEBUG_FIELDS, options)), \"]\"));\n    } // Response options\n\n\n    _this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    }; // Flushing\n\n    _this.flushing = false;\n    _this.queue = []; // Internal state\n\n    _this.writeStream = null;\n    _this.destroyed = false;\n    _this.timedOut = false; // Create hash method\n\n    var hash = crypto.createHash('sha1');\n    hash.update(_this.address);\n    _this.hashedName = hash.digest('hex'); // All operations in flight on the connection\n\n    _this.workItems = []; // setup socket\n\n    _this.socket = socket;\n\n    _this.socket.once('error', errorHandler(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.socket.once('timeout', timeoutHandler(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.socket.once('close', closeHandler(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    _this.socket.on('data', dataHandler(_assertThisInitialized(_assertThisInitialized(_this))));\n\n    if (connectionAccounting) {\n      addConnection(_this.id, _assertThisInitialized(_assertThisInitialized(_this)));\n    }\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"setSocketTimeout\",\n    value: function setSocketTimeout(value) {\n      if (this.socket) {\n        this.socket.setTimeout(value);\n      }\n    }\n  }, {\n    key: \"resetSocketTimeout\",\n    value: function resetSocketTimeout() {\n      if (this.socket) {\n        this.socket.setTimeout(this.socketTimeout);\n      }\n    }\n  }, {\n    key: \"unref\",\n\n    /**\n     * Unref this connection\n     * @method\n     * @return {boolean}\n     */\n    value: function unref() {\n      var _this2 = this;\n\n      if (this.socket == null) {\n        this.once('connect', function () {\n          return _this2.socket.unref();\n        });\n        return;\n      }\n\n      this.socket.unref();\n    }\n    /**\n     * Flush all work Items on this connection\n     *\n     * @param {*} err The error to propagate to the flushed work items\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush(err) {\n      while (this.workItems.length > 0) {\n        var workItem = this.workItems.shift();\n\n        if (workItem.cb) {\n          workItem.cb(err);\n        }\n      }\n    }\n    /**\n     * Destroy connection\n     * @method\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = Object.assign({\n        force: false\n      }, options);\n\n      if (connectionAccounting) {\n        deleteConnection(this.id);\n      }\n\n      if (this.socket == null) {\n        this.destroyed = true;\n        return;\n      }\n\n      if (options.force || this.timedOut) {\n        this.socket.destroy();\n        this.destroyed = true;\n        if (typeof callback === 'function') callback(null, null);\n        return;\n      }\n\n      this.socket.end(function (err) {\n        _this3.destroyed = true;\n        if (typeof callback === 'function') callback(err, null);\n      });\n    }\n    /**\n     * Write to connection\n     * @method\n     * @param {Command} command Command to write out need to implement toBin and toBinUnified\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(buffer) {\n      // Debug Log\n      if (this.logger.isDebug()) {\n        if (!Array.isArray(buffer)) {\n          this.logger.debug(\"writing buffer [\".concat(buffer.toString('hex'), \"] to \").concat(this.address));\n        } else {\n          for (var i = 0; i < buffer.length; i++) {\n            this.logger.debug(\"writing buffer [\".concat(buffer[i].toString('hex'), \"] to \").concat(this.address));\n          }\n        }\n      } // Double check that the connection is not destroyed\n\n\n      if (this.socket.destroyed === false) {\n        // Write out the command\n        if (!Array.isArray(buffer)) {\n          this.socket.write(buffer, 'binary');\n          return true;\n        } // Iterate over all buffers and write them in order to the socket\n\n\n        for (var _i = 0; _i < buffer.length; _i++) {\n          this.socket.write(buffer[_i], 'binary');\n        }\n\n        return true;\n      } // Connection is destroyed return write failed\n\n\n      return false;\n    }\n    /**\n     * Return id of connection as a string\n     * @method\n     * @return {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '' + this.id;\n    }\n    /**\n     * Return json object of connection\n     * @method\n     * @return {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.id,\n        host: this.host,\n        port: this.port\n      };\n    }\n    /**\n     * Is the connection connected\n     * @method\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      if (this.destroyed) return false;\n      return !this.socket.destroyed && this.socket.writable;\n    }\n  }, {\n    key: \"address\",\n    get: function get() {\n      return \"\".concat(this.host, \":\").concat(this.port);\n    }\n  }], [{\n    key: \"enableConnectionAccounting\",\n    value: function enableConnectionAccounting(spy) {\n      if (spy) {\n        connectionAccountingSpy = spy;\n      }\n\n      connectionAccounting = true;\n      _connections = {};\n    }\n  }, {\n    key: \"disableConnectionAccounting\",\n    value: function disableConnectionAccounting() {\n      connectionAccounting = false;\n      connectionAccountingSpy = undefined;\n    }\n  }, {\n    key: \"connections\",\n    value: function connections() {\n      return _connections;\n    }\n  }]);\n\n  return Connection;\n}(EventEmitter);\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete _connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  _connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n} //\n// Connection handlers\n\n\nfunction errorHandler(conn) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(conn.id); // Debug information\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\"connection \".concat(conn.id, \" for [\").concat(conn.address, \"] errored out with [\").concat(JSON.stringify(err), \"]\"));\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function () {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\"connection \".concat(conn.id, \" for [\").concat(conn.address, \"] timed out\"));\n    }\n\n    conn.timedOut = true;\n    conn.emit('timeout', new MongoNetworkError(\"connection \".concat(conn.id, \" to \").concat(conn.address, \" timed out\")), conn);\n  };\n}\n\nfunction closeHandler(conn) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\"connection \".concat(conn.id, \" with for [\").concat(conn.address, \"] closed\"));\n    }\n\n    if (!hadError) {\n      conn.emit('close', new MongoNetworkError(\"connection \".concat(conn.id, \" to \").concat(conn.address, \" closed\")), conn);\n    }\n  };\n} // Handle a message once it is received\n\n\nfunction processMessage(conn, message) {\n  var msgHeader = parseHeader(message);\n\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    var ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  var index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  var compressorID = message[index];\n  index++;\n  decompress(compressorID, message.slice(index), function (err, decompressedMsgBody) {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit('error', new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    var ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);\n  });\n}\n\nfunction dataHandler(conn) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        var remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          conn.bytesRead = conn.bytesRead + data.length; // Reset state of buffer\n\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          var emitBuffer = conn.buffer; // Reset state of buffer\n\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            var newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            var newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            conn.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, conn.stubBuffer.length); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              var errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {\n              conn.buffer = Buffer.alloc(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(conn.buffer, 0); // Update bytes read\n\n              conn.bytesRead = data.length; // Update sizeOfMessage\n\n              conn.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {\n              var _emitBuffer = data; // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0); // Emit the message\n\n              processMessage(conn, _emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              var _errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', _errorObject, conn); // Clear out the state of the parser\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else {\n              var _emitBuffer2 = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              processMessage(conn, _emitBuffer2);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length); // Copy the data to the stub buffer\n\n            data.copy(conn.stubBuffer, 0); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}