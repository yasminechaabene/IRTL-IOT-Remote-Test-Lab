{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar EventEmitter = require('events'),\n    MongoError = require('../core').MongoError,\n    f = require('util').format,\n    translateReadPreference = require('../utils').translateReadPreference,\n    ClientSession = require('../core').Sessions.ClientSession; // The store of ops\n\n\nvar Store = function Store(topology, storeOptions) {\n  var self = this;\n  var storedOps = [];\n  storeOptions = storeOptions || {\n    force: false,\n    bufferMaxEntries: -1\n  }; // Internal state\n\n  this.s = {\n    storedOps: storedOps,\n    storeOptions: storeOptions,\n    topology: topology\n  };\n  Object.defineProperty(this, 'length', {\n    enumerable: true,\n    get: function get() {\n      return self.s.storedOps.length;\n    }\n  });\n};\n\nStore.prototype.add = function (opType, ns, ops, options, callback) {\n  if (this.s.storeOptions.force) {\n    return callback(MongoError.create({\n      message: 'db closed by application',\n      driver: true\n    }));\n  }\n\n  if (this.s.storeOptions.bufferMaxEntries === 0) {\n    return callback(MongoError.create({\n      message: f('no connection available for operation and number of stored operation > %s', this.s.storeOptions.bufferMaxEntries),\n      driver: true\n    }));\n  }\n\n  if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {\n    while (this.s.storedOps.length > 0) {\n      var op = this.s.storedOps.shift();\n      op.c(MongoError.create({\n        message: f('no connection available for operation and number of stored operation > %s', this.s.storeOptions.bufferMaxEntries),\n        driver: true\n      }));\n    }\n\n    return;\n  }\n\n  this.s.storedOps.push({\n    t: opType,\n    n: ns,\n    o: ops,\n    op: options,\n    c: callback\n  });\n};\n\nStore.prototype.addObjectAndMethod = function (opType, object, method, params, callback) {\n  if (this.s.storeOptions.force) {\n    return callback(MongoError.create({\n      message: 'db closed by application',\n      driver: true\n    }));\n  }\n\n  if (this.s.storeOptions.bufferMaxEntries === 0) {\n    return callback(MongoError.create({\n      message: f('no connection available for operation and number of stored operation > %s', this.s.storeOptions.bufferMaxEntries),\n      driver: true\n    }));\n  }\n\n  if (this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {\n    while (this.s.storedOps.length > 0) {\n      var op = this.s.storedOps.shift();\n      op.c(MongoError.create({\n        message: f('no connection available for operation and number of stored operation > %s', this.s.storeOptions.bufferMaxEntries),\n        driver: true\n      }));\n    }\n\n    return;\n  }\n\n  this.s.storedOps.push({\n    t: opType,\n    m: method,\n    o: object,\n    p: params,\n    c: callback\n  });\n};\n\nStore.prototype.flush = function (err) {\n  while (this.s.storedOps.length > 0) {\n    this.s.storedOps.shift().c(err || MongoError.create({\n      message: f('no connection available for operation'),\n      driver: true\n    }));\n  }\n};\n\nvar primaryOptions = ['primary', 'primaryPreferred', 'nearest', 'secondaryPreferred'];\nvar secondaryOptions = ['secondary', 'secondaryPreferred'];\n\nStore.prototype.execute = function (options) {\n  options = options || {}; // Get current ops\n\n  var ops = this.s.storedOps; // Reset the ops\n\n  this.s.storedOps = []; // Unpack options\n\n  var executePrimary = typeof options.executePrimary === 'boolean' ? options.executePrimary : true;\n  var executeSecondary = typeof options.executeSecondary === 'boolean' ? options.executeSecondary : true; // Execute all the stored ops\n\n  while (ops.length > 0) {\n    var op = ops.shift();\n\n    if (op.t === 'cursor') {\n      if (executePrimary && executeSecondary) {\n        op.o[op.m].apply(op.o, op.p);\n      } else if (executePrimary && op.o.options && op.o.options.readPreference && primaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {\n        op.o[op.m].apply(op.o, op.p);\n      } else if (!executePrimary && executeSecondary && op.o.options && op.o.options.readPreference && secondaryOptions.indexOf(op.o.options.readPreference.mode) !== -1) {\n        op.o[op.m].apply(op.o, op.p);\n      }\n    } else if (op.t === 'auth') {\n      this.s.topology[op.t].apply(this.s.topology, op.o);\n    } else {\n      if (executePrimary && executeSecondary) {\n        this.s.topology[op.t](op.n, op.o, op.op, op.c);\n      } else if (executePrimary && op.op && op.op.readPreference && primaryOptions.indexOf(op.op.readPreference.mode) !== -1) {\n        this.s.topology[op.t](op.n, op.o, op.op, op.c);\n      } else if (!executePrimary && executeSecondary && op.op && op.op.readPreference && secondaryOptions.indexOf(op.op.readPreference.mode) !== -1) {\n        this.s.topology[op.t](op.n, op.o, op.op, op.c);\n      }\n    }\n  }\n};\n\nStore.prototype.all = function () {\n  return this.s.storedOps;\n}; // Server capabilities\n\n\nvar ServerCapabilities = function ServerCapabilities(ismaster) {\n  var setup_get_property = function setup_get_property(object, name, value) {\n    Object.defineProperty(object, name, {\n      enumerable: true,\n      get: function get() {\n        return value;\n      }\n    });\n  }; // Capabilities\n\n\n  var aggregationCursor = false;\n  var writeCommands = false;\n  var textSearch = false;\n  var authCommands = false;\n  var listCollections = false;\n  var listIndexes = false;\n  var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1000;\n  var commandsTakeWriteConcern = false;\n  var commandsTakeCollation = false;\n\n  if (ismaster.minWireVersion >= 0) {\n    textSearch = true;\n  }\n\n  if (ismaster.maxWireVersion >= 1) {\n    aggregationCursor = true;\n    authCommands = true;\n  }\n\n  if (ismaster.maxWireVersion >= 2) {\n    writeCommands = true;\n  }\n\n  if (ismaster.maxWireVersion >= 3) {\n    listCollections = true;\n    listIndexes = true;\n  }\n\n  if (ismaster.maxWireVersion >= 5) {\n    commandsTakeWriteConcern = true;\n    commandsTakeCollation = true;\n  } // If no min or max wire version set to 0\n\n\n  if (ismaster.minWireVersion == null) {\n    ismaster.minWireVersion = 0;\n  }\n\n  if (ismaster.maxWireVersion == null) {\n    ismaster.maxWireVersion = 0;\n  } // Map up read only parameters\n\n\n  setup_get_property(this, 'hasAggregationCursor', aggregationCursor);\n  setup_get_property(this, 'hasWriteCommands', writeCommands);\n  setup_get_property(this, 'hasTextSearch', textSearch);\n  setup_get_property(this, 'hasAuthCommands', authCommands);\n  setup_get_property(this, 'hasListCollectionsCommand', listCollections);\n  setup_get_property(this, 'hasListIndexesCommand', listIndexes);\n  setup_get_property(this, 'minWireVersion', ismaster.minWireVersion);\n  setup_get_property(this, 'maxWireVersion', ismaster.maxWireVersion);\n  setup_get_property(this, 'maxNumberOfDocsInBatch', maxNumberOfDocsInBatch);\n  setup_get_property(this, 'commandsTakeWriteConcern', commandsTakeWriteConcern);\n  setup_get_property(this, 'commandsTakeCollation', commandsTakeCollation);\n};\n\nvar TopologyBase = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(TopologyBase, _EventEmitter);\n\n  function TopologyBase() {\n    var _this;\n\n    _classCallCheck(this, TopologyBase);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TopologyBase).call(this));\n\n    _this.setMaxListeners(Infinity);\n\n    return _this;\n  } // Sessions related methods\n\n\n  _createClass(TopologyBase, [{\n    key: \"hasSessionSupport\",\n    value: function hasSessionSupport() {\n      return this.logicalSessionTimeoutMinutes != null;\n    }\n  }, {\n    key: \"startSession\",\n    value: function startSession(options, clientOptions) {\n      var _this2 = this;\n\n      var session = new ClientSession(this, this.s.sessionPool, options, clientOptions);\n      session.once('ended', function () {\n        _this2.s.sessions.delete(session);\n      });\n      this.s.sessions.add(session);\n      return session;\n    }\n  }, {\n    key: \"endSessions\",\n    value: function endSessions(sessions, callback) {\n      return this.s.coreTopology.endSessions(sessions, callback);\n    }\n  }, {\n    key: \"capabilities\",\n    // Server capabilities\n    value: function capabilities() {\n      if (this.s.sCapabilities) return this.s.sCapabilities;\n      if (this.s.coreTopology.lastIsMaster() == null) return null;\n      this.s.sCapabilities = new ServerCapabilities(this.s.coreTopology.lastIsMaster());\n      return this.s.sCapabilities;\n    } // Command\n\n  }, {\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      this.s.coreTopology.command(ns.toString(), cmd, translateReadPreference(options), callback);\n    } // Insert\n\n  }, {\n    key: \"insert\",\n    value: function insert(ns, ops, options, callback) {\n      this.s.coreTopology.insert(ns.toString(), ops, options, callback);\n    } // Update\n\n  }, {\n    key: \"update\",\n    value: function update(ns, ops, options, callback) {\n      this.s.coreTopology.update(ns.toString(), ops, options, callback);\n    } // Remove\n\n  }, {\n    key: \"remove\",\n    value: function remove(ns, ops, options, callback) {\n      this.s.coreTopology.remove(ns.toString(), ops, options, callback);\n    } // IsConnected\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected(options) {\n      options = options || {};\n      options = translateReadPreference(options);\n      return this.s.coreTopology.isConnected(options);\n    } // IsDestroyed\n\n  }, {\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      return this.s.coreTopology.isDestroyed();\n    } // Cursor\n\n  }, {\n    key: \"cursor\",\n    value: function cursor(ns, cmd, options) {\n      options = options || {};\n      options = translateReadPreference(options);\n      options.disconnectHandler = this.s.store;\n      options.topology = this;\n      return this.s.coreTopology.cursor(ns, cmd, options);\n    }\n  }, {\n    key: \"lastIsMaster\",\n    value: function lastIsMaster() {\n      return this.s.coreTopology.lastIsMaster();\n    }\n  }, {\n    key: \"selectServer\",\n    value: function selectServer(selector, options, callback) {\n      return this.s.coreTopology.selectServer(selector, options, callback);\n    }\n    /**\n     * Unref all sockets\n     * @method\n     */\n\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      return this.s.coreTopology.unref();\n    }\n    /**\n     * All raw connections\n     * @method\n     * @return {array}\n     */\n\n  }, {\n    key: \"connections\",\n    value: function connections() {\n      return this.s.coreTopology.connections();\n    }\n  }, {\n    key: \"close\",\n    value: function close(forceClosed, callback) {\n      // If we have sessions, we want to individually move them to the session pool,\n      // and then send a single endSessions call.\n      this.s.sessions.forEach(function (session) {\n        return session.endSession();\n      });\n\n      if (this.s.sessionPool) {\n        this.s.sessionPool.endAllPooledSessions();\n      } // We need to wash out all stored processes\n\n\n      if (forceClosed === true) {\n        this.s.storeOptions.force = forceClosed;\n        this.s.store.flush();\n      }\n\n      this.s.coreTopology.destroy({\n        force: typeof forceClosed === 'boolean' ? forceClosed : false\n      }, callback);\n    }\n  }, {\n    key: \"clientMetadata\",\n    get: function get() {\n      return this.s.coreTopology.s.options.metadata;\n    }\n  }]);\n\n  return TopologyBase;\n}(EventEmitter); // Properties\n\n\nObject.defineProperty(TopologyBase.prototype, 'bson', {\n  enumerable: true,\n  get: function get() {\n    return this.s.coreTopology.s.bson;\n  }\n});\nObject.defineProperty(TopologyBase.prototype, 'parserType', {\n  enumerable: true,\n  get: function get() {\n    return this.s.coreTopology.parserType;\n  }\n});\nObject.defineProperty(TopologyBase.prototype, 'logicalSessionTimeoutMinutes', {\n  enumerable: true,\n  get: function get() {\n    return this.s.coreTopology.logicalSessionTimeoutMinutes;\n  }\n});\nObject.defineProperty(TopologyBase.prototype, 'type', {\n  enumerable: true,\n  get: function get() {\n    return this.s.coreTopology.type;\n  }\n});\nexports.Store = Store;\nexports.ServerCapabilities = ServerCapabilities;\nexports.TopologyBase = TopologyBase;","map":null,"metadata":{},"sourceType":"script"}