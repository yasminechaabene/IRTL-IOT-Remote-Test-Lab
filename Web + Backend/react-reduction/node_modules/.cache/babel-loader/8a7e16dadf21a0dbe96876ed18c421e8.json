{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar Duplex = require('stream').Duplex;\n\nvar BufferList = require('bl');\n\nvar MongoParseError = require('../core/error').MongoParseError;\n\nvar decompress = require('../core/wireprotocol/compression').decompress;\n\nvar Response = require('../core/connection/commands').Response;\n\nvar BinMsg = require('../core/connection/msg').BinMsg;\n\nvar MongoError = require('../core/error').MongoError;\n\nvar OP_COMPRESSED = require('../core/wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nvar OP_MSG = require('../core/wireprotocol/shared').opcodes.OP_MSG;\n\nvar MESSAGE_HEADER_SIZE = require('../core/wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nvar COMPRESSION_DETAILS_SIZE = require('../core/wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\n\nvar opcodes = require('../core/wireprotocol/shared').opcodes;\n\nvar compress = require('../core/wireprotocol/compression').compress;\n\nvar compressorIDs = require('../core/wireprotocol/compression').compressorIDs;\n\nvar uncompressibleCommands = require('../core/wireprotocol/compression').uncompressibleCommands;\n\nvar Msg = require('../core/connection/msg').Msg;\n\nvar kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\nvar kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n */\n\nvar MessageStream = /*#__PURE__*/function (_Duplex) {\n  _inherits(MessageStream, _Duplex);\n\n  function MessageStream(options) {\n    var _this;\n\n    _classCallCheck(this, MessageStream);\n\n    options = options || {};\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MessageStream).call(this, options));\n    _this.bson = options.bson;\n    _this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    _this[kBuffer] = new BufferList();\n    return _this;\n  }\n\n  _createClass(MessageStream, [{\n    key: \"_write\",\n    value: function _write(chunk, _, callback) {\n      var buffer = this[kBuffer];\n      buffer.append(chunk);\n      processIncomingData(this, callback);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read()\n    /* size */\n    {\n      // NOTE: This implementation is empty because we explicitly push data to be read\n      //       when `writeMessage` is called.\n      return;\n    }\n  }, {\n    key: \"writeCommand\",\n    value: function writeCommand(command, operationDescription) {\n      var _this2 = this;\n\n      // TODO: agreed compressor should live in `StreamDescription`\n      var shouldCompress = operationDescription && !!operationDescription.agreedCompressor;\n\n      if (!shouldCompress || !canCompress(command)) {\n        var data = command.toBin();\n        this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n        return;\n      } // otherwise, compress the message\n\n\n      var concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n      var messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n      var originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n      compress({\n        options: operationDescription\n      }, messageToBeCompressed, function (err, compressedMessage) {\n        if (err) {\n          operationDescription.cb(err, null);\n          return;\n        } // Create the msgHeader of OP_COMPRESSED\n\n\n        var msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n        msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n        msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n        msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n        // Create the compression details of OP_COMPRESSED\n\n        var compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n        compressionDetails.writeUInt8(compressorIDs[operationDescription.agreedCompressor], 8); // compressorID\n\n        _this2.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n      });\n    }\n  }]);\n\n  return MessageStream;\n}(Duplex); // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nfunction canCompress(command) {\n  var commandDoc = command instanceof Msg ? command.command : command.query;\n  var commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  var buffer = stream[kBuffer];\n\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  var sizeOfMessage = buffer.readInt32LE(0);\n\n  if (sizeOfMessage < 0) {\n    callback(new MongoParseError(\"Invalid message size: \".concat(sizeOfMessage)));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new MongoParseError(\"Invalid message size: \".concat(sizeOfMessage, \", max allowed: \").concat(stream.maxBsonMessageSize)));\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  var message = buffer.slice(0, sizeOfMessage);\n  buffer.consume(sizeOfMessage);\n  var messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  var ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  var responseOptions = stream.responseOptions;\n\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    var messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  var compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  var compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === OP_MSG ? BinMsg : Response;\n  decompress(compressorID, compressedBuffer, function (err, messageBody) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    stream.emit('message', new ResponseType(stream.bson, message, messageHeader, messageBody, responseOptions));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}\n\nmodule.exports = MessageStream;","map":null,"metadata":{},"sourceType":"script"}