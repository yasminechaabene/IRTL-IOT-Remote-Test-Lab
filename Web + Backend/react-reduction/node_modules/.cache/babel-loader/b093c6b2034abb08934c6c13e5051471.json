{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _makeStateMachine;\n\nvar ServerType = require('./common').ServerType;\n\nvar calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nvar EventEmitter = require('events');\n\nvar connect = require('../connection/connect');\n\nvar Connection = require('../../cmap/connection').Connection;\n\nvar common = require('./common');\n\nvar makeStateMachine = require('../utils').makeStateMachine;\n\nvar MongoError = require('../error').MongoError;\n\nvar sdamEvents = require('./events');\n\nvar ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nvar ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nvar ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nvar kServer = Symbol('server');\nvar kMonitorId = Symbol('monitorId');\nvar kConnection = Symbol('connection');\nvar kCancellationToken = Symbol('cancellationToken');\nvar kLastCheckTime = Symbol('lastCheckTime');\nvar STATE_CLOSED = common.STATE_CLOSED;\nvar STATE_CLOSING = common.STATE_CLOSING;\nvar STATE_IDLE = 'idle';\nvar STATE_MONITORING = 'monitoring';\nvar stateTransition = makeStateMachine((_makeStateMachine = {}, _defineProperty(_makeStateMachine, STATE_CLOSING, [STATE_CLOSING, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CLOSED, [STATE_CLOSED, STATE_MONITORING]), _defineProperty(_makeStateMachine, STATE_IDLE, [STATE_IDLE, STATE_MONITORING, STATE_CLOSING]), _defineProperty(_makeStateMachine, STATE_MONITORING, [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]), _makeStateMachine));\nvar INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nvar Monitor = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Monitor, _EventEmitter);\n\n  function Monitor(server, options) {\n    var _this;\n\n    _classCallCheck(this, Monitor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Monitor).call(this, options));\n    _this[kServer] = server;\n    _this[kConnection] = undefined;\n    _this[kCancellationToken] = new EventEmitter();\n\n    _this[kCancellationToken].setMaxListeners(Infinity);\n\n    _this.s = {\n      state: STATE_CLOSED\n    };\n    _this.address = server.description.address;\n    _this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    var addressParts = server.description.address.split(':');\n    _this.connectOptions = Object.freeze(Object.assign({\n      id: '<monitor>',\n      host: addressParts[0],\n      port: parseInt(addressParts[1], 10),\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, _this.options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }));\n    return _this;\n  }\n\n  _createClass(Monitor, [{\n    key: \"connect\",\n    value: function connect() {\n      if (this.s.state !== STATE_CLOSED) {\n        return;\n      }\n\n      monitorServer(this);\n    }\n  }, {\n    key: \"requestCheck\",\n    value: function requestCheck() {\n      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n        return;\n      }\n\n      var heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n      var minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n      var remainingTime = heartbeatFrequencyMS - calculateDurationInMs(this[kLastCheckTime]);\n\n      if (remainingTime > minHeartbeatFrequencyMS && this[kMonitorId]) {\n        clearTimeout(this[kMonitorId]);\n        rescheduleMonitoring(this, minHeartbeatFrequencyMS);\n        return;\n      }\n\n      if (this[kMonitorId]) {\n        clearTimeout(this[kMonitorId]);\n      }\n\n      monitorServer(this);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.s.state === STATE_CLOSED || this.s.state === STATE_CLOSING) {\n        return;\n      }\n\n      stateTransition(this, STATE_CLOSING);\n      this[kCancellationToken].emit('cancel');\n\n      if (this[kMonitorId]) {\n        clearTimeout(this[kMonitorId]);\n      }\n\n      if (this[kConnection]) {\n        this[kConnection].destroy({\n          force: true\n        });\n      }\n\n      this.emit('close');\n      stateTransition(this, STATE_CLOSED);\n    }\n  }]);\n\n  return Monitor;\n}(EventEmitter);\n\nfunction checkServer(monitor, callback) {\n  if (monitor[kConnection] && monitor[kConnection].closed) {\n    monitor[kConnection] = undefined;\n  }\n\n  var start = process.hrtime();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    callback(err);\n  }\n\n  function successHandler(isMaster) {\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), isMaster, monitor.address));\n    return callback(undefined, isMaster);\n  }\n\n  if (monitor[kConnection] != null) {\n    var connectTimeoutMS = monitor.options.connectTimeoutMS;\n    monitor[kConnection].command('admin.$cmd', {\n      ismaster: true\n    }, {\n      socketTimeout: connectTimeoutMS\n    }, function (err, result) {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      successHandler(result.result);\n    });\n    return;\n  } // connecting does an implicit `ismaster`\n\n\n  connect(monitor.connectOptions, monitor[kCancellationToken], function (err, conn) {\n    if (err) {\n      monitor[kConnection] = undefined;\n      failureHandler(err);\n      return;\n    }\n\n    if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {\n      conn.destroy({\n        force: true\n      });\n      failureHandler(new MongoError('monitor was destroyed'));\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    successHandler(conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  stateTransition(monitor, STATE_MONITORING); // TODO: the next line is a legacy event, remove in v4\n\n  process.nextTick(function () {\n    return monitor.emit('monitoring', monitor[kServer]);\n  });\n  checkServer(monitor, function (e0) {\n    if (e0 == null) {\n      rescheduleMonitoring(monitor);\n      return;\n    } // otherwise an error occured on initial discovery, also bail\n\n\n    if (monitor[kServer].description.type === ServerType.Unknown) {\n      monitor.emit('resetServer', e0);\n      rescheduleMonitoring(monitor);\n      return;\n    } // According to the SDAM specification's \"Network error during server check\" section, if\n    // an ismaster call fails we reset the server's pool. If a server was once connected,\n    // change its type to `Unknown` only after retrying once.\n\n\n    monitor.emit('resetConnectionPool');\n    checkServer(monitor, function (e1) {\n      if (e1) {\n        monitor.emit('resetServer', e1);\n      }\n\n      rescheduleMonitoring(monitor);\n    });\n  });\n}\n\nfunction rescheduleMonitoring(monitor, ms) {\n  var heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;\n\n  if (monitor.s.state === STATE_CLOSING || monitor.s.state === STATE_CLOSED) {\n    return;\n  }\n\n  stateTransition(monitor, STATE_IDLE);\n  monitor[kLastCheckTime] = process.hrtime();\n  monitor[kMonitorId] = setTimeout(function () {\n    monitor[kMonitorId] = undefined;\n    monitor.requestCheck();\n  }, ms || heartbeatFrequencyMS);\n}\n\nmodule.exports = {\n  Monitor: Monitor\n};","map":null,"metadata":{},"sourceType":"script"}