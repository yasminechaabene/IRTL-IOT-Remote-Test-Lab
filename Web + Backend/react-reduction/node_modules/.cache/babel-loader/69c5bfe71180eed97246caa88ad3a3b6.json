{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar ServerType = require('./common').ServerType;\n\nvar ServerDescription = require('./server_description').ServerDescription;\n\nvar WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nvar TopologyType = require('./common').TopologyType; // contstants related to compatability checks\n\n\nvar MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nvar MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nvar MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nvar MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION; // Representation of a deployment of servers\n\nvar TopologyDescription = /*#__PURE__*/function () {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  function TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    _classCallCheck(this, TopologyDescription);\n\n    options = options || {}; // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null; // save this locally, but don't display when printing the instance out\n\n    Object.defineProperty(this, 'options', {\n      value: options,\n      enumberable: false\n    }); // determine server compatibility\n\n    var _iterator = _createForOfIteratorHelper(this.servers.values()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var serverDescription = _step.value;\n        if (serverDescription.type === ServerType.Unknown) continue;\n\n        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n          this.compatible = false;\n          this.compatibilityError = \"Server at \".concat(serverDescription.address, \" requires wire version \").concat(serverDescription.minWireVersion, \", but this version of the driver only supports up to \").concat(MAX_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(MAX_SUPPORTED_SERVER_VERSION, \")\");\n        }\n\n        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n          this.compatible = false;\n          this.compatibilityError = \"Server at \".concat(serverDescription.address, \" reports wire version \").concat(serverDescription.maxWireVersion, \", but this version of the driver requires at least \").concat(MIN_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(MIN_SUPPORTED_SERVER_VERSION, \").\");\n          break;\n        }\n      } // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n      // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n      // value among ServerDescriptions of all data-bearing server types. If any have a null\n      // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n      // set to null.\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var readableServers = Array.from(this.servers.values()).filter(function (s) {\n      return s.isReadable;\n    });\n    this.logicalSessionTimeoutMinutes = readableServers.reduce(function (result, server) {\n      if (server.logicalSessionTimeoutMinutes == null) return null;\n      if (result == null) return server.logicalSessionTimeoutMinutes;\n      return Math.min(result, server.logicalSessionTimeoutMinutes);\n    }, null);\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n\n\n  _createClass(TopologyDescription, [{\n    key: \"updateFromSrvPollingEvent\",\n    value: function updateFromSrvPollingEvent(ev) {\n      var newAddresses = ev.addresses();\n      var serverDescriptions = new Map(this.servers);\n\n      var _iterator2 = _createForOfIteratorHelper(this.servers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var server = _step2.value;\n\n          if (newAddresses.has(server[0])) {\n            newAddresses.delete(server[0]);\n          } else {\n            serverDescriptions.delete(server[0]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n        return this;\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(newAddresses),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var address = _step3.value;\n          serverDescriptions.set(address, new ServerDescription(address));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);\n    }\n    /**\n     * Returns a copy of this description updated with a given ServerDescription\n     *\n     * @param {ServerDescription} serverDescription\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(serverDescription) {\n      var address = serverDescription.address; // NOTE: there are a number of prime targets for refactoring here\n      //       once we support destructuring assignments\n      // potentially mutated values\n\n      var topologyType = this.type;\n      var setName = this.setName;\n      var maxSetVersion = this.maxSetVersion;\n      var maxElectionId = this.maxElectionId;\n      var commonWireVersion = this.commonWireVersion;\n      var serverType = serverDescription.type;\n      var serverDescriptions = new Map(this.servers); // update common wire version\n\n      if (serverDescription.maxWireVersion !== 0) {\n        if (commonWireVersion == null) {\n          commonWireVersion = serverDescription.maxWireVersion;\n        } else {\n          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n        }\n      } // update the actual server description\n\n\n      serverDescriptions.set(address, serverDescription);\n\n      if (topologyType === TopologyType.Single) {\n        // once we are defined as single, that never changes\n        return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n      }\n\n      if (topologyType === TopologyType.Unknown) {\n        if (serverType === ServerType.Standalone) {\n          serverDescriptions.delete(address);\n        } else {\n          topologyType = topologyTypeForServerType(serverType);\n        }\n      }\n\n      if (topologyType === TopologyType.Sharded) {\n        if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n          serverDescriptions.delete(address);\n        }\n      }\n\n      if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n          serverDescriptions.delete(address);\n        }\n\n        if (serverType === ServerType.RSPrimary) {\n          var result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n          topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n          var _result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n\n          topologyType = _result[0], setName = _result[1];\n        }\n      }\n\n      if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n        if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n          serverDescriptions.delete(address);\n          topologyType = checkHasPrimary(serverDescriptions);\n        } else if (serverType === ServerType.RSPrimary) {\n          var _result2 = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n\n          topologyType = _result2[0], setName = _result2[1], maxSetVersion = _result2[2], maxElectionId = _result2[3];\n        } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        } else {\n          topologyType = checkHasPrimary(serverDescriptions);\n        }\n      }\n\n      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n    }\n  }, {\n    key: \"hasServer\",\n\n    /**\n     * Determines if the topology has a definition for the provided address\n     *\n     * @param {String} address\n     * @return {Boolean} Whether the topology knows about this server\n     */\n    value: function hasServer(address) {\n      return this.servers.has(address);\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      var descriptionsWithError = Array.from(this.servers.values()).filter(function (sd) {\n        return sd.error;\n      });\n\n      if (descriptionsWithError.length > 0) {\n        return descriptionsWithError[0].error;\n      }\n    }\n    /**\n     * Determines if the topology description has any known servers\n     */\n\n  }, {\n    key: \"hasKnownServers\",\n    get: function get() {\n      return Array.from(this.servers.values()).some(function (sd) {\n        return sd.type !== ServerType.Unknown;\n      });\n    }\n    /**\n     * Determines if this topology description has a data-bearing server available.\n     */\n\n  }, {\n    key: \"hasDataBearingServers\",\n    get: function get() {\n      return Array.from(this.servers.values()).some(function (sd) {\n        return sd.isDataBearing;\n      });\n    }\n  }]);\n\n  return TopologyDescription;\n}();\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Mongos) return TopologyType.Sharded;\n  if (serverType === ServerType.RSPrimary) return TopologyType.ReplicaSetWithPrimary;\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    var oid1Buffer = oid1.id;\n    var oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  var oid1String = oid1.toString();\n  var oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  var electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  var _iterator4 = _createForOfIteratorHelper(serverDescriptions.keys()),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var address = _step4.value;\n      var server = serverDescriptions.get(address);\n\n      if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n        // Reset old primary's type to Unknown.\n        serverDescriptions.set(address, new ServerDescription(server.address)); // There can only be one primary\n\n        break;\n      }\n    } // Discover new hosts from this primary's response.\n\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  serverDescription.allHosts.forEach(function (address) {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  var currentAddresses = Array.from(serverDescriptions.keys());\n  var responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(function (addr) {\n    return responseAddresses.indexOf(addr) === -1;\n  }).forEach(function (address) {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  var topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(function (address) {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  var _iterator5 = _createForOfIteratorHelper(serverDescriptions.keys()),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var addr = _step5.value;\n\n      if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n        return TopologyType.ReplicaSetWithPrimary;\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyDescription: TopologyDescription\n};","map":null,"metadata":{},"sourceType":"script"}