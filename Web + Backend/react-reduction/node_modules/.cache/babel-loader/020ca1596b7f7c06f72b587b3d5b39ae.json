{"ast":null,"code":"'use strict';\n\nvar Query = require('../connection/commands').Query;\n\nvar Msg = require('../connection/msg').Msg;\n\nvar MongoError = require('../error').MongoError;\n\nvar getReadPreference = require('./shared').getReadPreference;\n\nvar isSharded = require('./shared').isSharded;\n\nvar databaseNamespace = require('./shared').databaseNamespace;\n\nvar isTransactionCommand = require('../transactions').isTransactionCommand;\n\nvar applySession = require('../sessions').applySession;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar maxWireVersion = require('../utils').maxWireVersion;\n\nfunction isClientEncryptionEnabled(server) {\n  var wireVersion = maxWireVersion(server);\n  return wireVersion && server.autoEncrypter;\n}\n\nfunction command(server, ns, cmd, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n\n  if (cmd == null) {\n    return callback(new MongoError(\"command \".concat(JSON.stringify(cmd), \" does not return a cursor\")));\n  }\n\n  if (!isClientEncryptionEnabled(server)) {\n    _command(server, ns, cmd, options, callback);\n\n    return;\n  }\n\n  var wireVersion = maxWireVersion(server);\n\n  if (typeof wireVersion !== 'number' || wireVersion < 8) {\n    callback(new MongoError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n    return;\n  }\n\n  _cryptCommand(server, ns, cmd, options, callback);\n}\n\nfunction _command(server, ns, cmd, options, callback) {\n  var bson = server.s.bson;\n  var pool = server.s.pool;\n  var readPreference = getReadPreference(cmd, options);\n  var shouldUseOpMsg = supportsOpMsg(server);\n  var session = options.session;\n  var clusterTime = server.clusterTime;\n  var finalCmd = Object.assign({}, cmd);\n\n  if (hasSessionSupport(server) && session) {\n    if (session.clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n      clusterTime = session.clusterTime;\n    }\n\n    var err = applySession(session, finalCmd, options);\n\n    if (err) {\n      return callback(err);\n    }\n  } // if we have a known cluster time, gossip it\n\n\n  if (clusterTime) {\n    finalCmd.$clusterTime = clusterTime;\n  }\n\n  if (isSharded(server) && !shouldUseOpMsg && readPreference && readPreference.preference !== 'primary') {\n    finalCmd = {\n      $query: finalCmd,\n      $readPreference: readPreference.toJSON()\n    };\n  }\n\n  var commandOptions = Object.assign({\n    command: true,\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: false\n  }, options); // This value is not overridable\n\n  commandOptions.slaveOk = readPreference.slaveOk();\n  var cmdNs = \"\".concat(databaseNamespace(ns), \".$cmd\");\n  var message = shouldUseOpMsg ? new Msg(bson, cmdNs, finalCmd, commandOptions) : new Query(bson, cmdNs, finalCmd, commandOptions);\n  var inTransaction = session && (session.inTransaction() || isTransactionCommand(finalCmd));\n  var commandResponseHandler = inTransaction ? function (err) {\n    // We need to add a TransientTransactionError errorLabel, as stated in the transaction spec.\n    if (err && err instanceof MongoNetworkError && !err.hasErrorLabel('TransientTransactionError')) {\n      if (err.errorLabels == null) {\n        err.errorLabels = [];\n      }\n\n      err.errorLabels.push('TransientTransactionError');\n    }\n\n    if (!cmd.commitTransaction && err && err instanceof MongoError && err.hasErrorLabel('TransientTransactionError')) {\n      session.transaction.unpinServer();\n    }\n\n    return callback.apply(null, arguments);\n  } : callback;\n\n  try {\n    pool.write(message, commandOptions, commandResponseHandler);\n  } catch (err) {\n    commandResponseHandler(err);\n  }\n}\n\nfunction hasSessionSupport(topology) {\n  if (topology == null) return false;\n\n  if (topology.description) {\n    return topology.description.maxWireVersion >= 6;\n  }\n\n  return topology.ismaster == null ? false : topology.ismaster.maxWireVersion >= 6;\n}\n\nfunction supportsOpMsg(topologyOrServer) {\n  var description = topologyOrServer.ismaster ? topologyOrServer.ismaster : topologyOrServer.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return description.maxWireVersion >= 6 && description.__nodejs_mock_server__ == null;\n}\n\nfunction _cryptCommand(server, ns, cmd, options, callback) {\n  var autoEncrypter = server.autoEncrypter;\n\n  function commandResponseHandler(err, response) {\n    if (err || response == null) {\n      callback(err, response);\n      return;\n    }\n\n    autoEncrypter.decrypt(response.result, options, function (err, decrypted) {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      response.result = decrypted;\n      response.message.documents = [decrypted];\n      callback(null, response);\n    });\n  }\n\n  autoEncrypter.encrypt(ns, cmd, options, function (err, encrypted) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    _command(server, ns, encrypted, options, commandResponseHandler);\n  });\n}\n\nmodule.exports = command;","map":null,"metadata":{},"sourceType":"script"}