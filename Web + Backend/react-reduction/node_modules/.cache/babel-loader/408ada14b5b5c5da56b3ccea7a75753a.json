{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar crypto = require('crypto');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar retrieveBSON = require('../connection/utils').retrieveBSON;\n\nvar MongoError = require('../error').MongoError;\n\nvar AuthProvider = require('./auth_provider').AuthProvider;\n\nvar BSON = retrieveBSON();\nvar Binary = BSON.Binary;\nvar saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nvar parsePayload = function parsePayload(payload) {\n  var dict = {};\n  var parts = payload.split(',');\n\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n};\n\nvar passwordDigest = function passwordDigest(username, password) {\n  if (typeof username !== 'string') throw new MongoError('username must be a string');\n  if (typeof password !== 'string') throw new MongoError('password must be a string');\n  if (password.length === 0) throw new MongoError('password cannot be empty'); // Use node md5 generator\n\n  var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n  md5.update(username + ':mongo:' + password, 'utf8');\n  return md5.digest('hex');\n}; // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n  var length = Math.max(a.length, b.length);\n  var res = [];\n\n  for (var i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\n\nvar _hiCachePurge = function _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n};\n\nvar hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  var key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  var result = 0;\n\n  for (var i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n/**\n * Creates a new ScramSHA authentication mechanism\n * @class\n * @extends AuthProvider\n */\n\n\nvar ScramSHA = /*#__PURE__*/function (_AuthProvider) {\n  _inherits(ScramSHA, _AuthProvider);\n\n  function ScramSHA(bson, cryptoMethod) {\n    var _this;\n\n    _classCallCheck(this, ScramSHA);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA).call(this, bson));\n    _this.cryptoMethod = cryptoMethod || 'sha1';\n    return _this;\n  }\n\n  _createClass(ScramSHA, [{\n    key: \"_executeScram\",\n\n    /**\n     * @ignore\n     */\n    value: function _executeScram(sendAuthCommand, connection, credentials, nonce, callback) {\n      var username = credentials.username;\n      var password = credentials.password;\n      var db = credentials.source;\n      var cryptoMethod = this.cryptoMethod;\n      var mechanism = 'SCRAM-SHA-1';\n      var processedPassword;\n\n      if (cryptoMethod === 'sha256') {\n        mechanism = 'SCRAM-SHA-256';\n        processedPassword = saslprep ? saslprep(password) : password;\n      } else {\n        try {\n          processedPassword = passwordDigest(username, password);\n        } catch (e) {\n          return callback(e);\n        }\n      } // Clean up the user\n\n\n      username = username.replace('=', '=3D').replace(',', '=2C'); // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n      // Since the username is not sasl-prep-d, we need to do this here.\n\n      var firstBare = Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce, 'utf8')]); // Build command structure\n\n      var saslStartCmd = {\n        saslStart: 1,\n        mechanism: mechanism,\n        payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),\n        autoAuthorize: 1\n      }; // Write the commmand on the connection\n\n      sendAuthCommand(connection, \"\".concat(db, \".$cmd\"), saslStartCmd, function (err, r) {\n        var tmpError = ScramSHA._getError(err, r);\n\n        if (tmpError) {\n          return callback(tmpError, null);\n        }\n\n        var payload = Buffer.isBuffer(r.payload) ? new Binary(r.payload) : r.payload;\n        var dict = parsePayload(payload.value());\n        var iterations = parseInt(dict.i, 10);\n\n        if (iterations && iterations < 4096) {\n          callback(new MongoError(\"Server returned an invalid iteration count \".concat(iterations)), false);\n          return;\n        }\n\n        var salt = dict.s;\n        var rnonce = dict.r;\n\n        if (rnonce.startsWith('nonce')) {\n          callback(new MongoError(\"Server returned an invalid nonce: \".concat(rnonce)), false);\n          return;\n        } // Set up start of proof\n\n\n        var withoutProof = \"c=biws,r=\".concat(rnonce);\n        var saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n        var clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n        var serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n        var storedKey = H(cryptoMethod, clientKey);\n        var authMessage = [firstBare, payload.value().toString('base64'), withoutProof].join(',');\n        var clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n        var clientProof = \"p=\".concat(xor(clientKey, clientSignature));\n        var clientFinal = [withoutProof, clientProof].join(',');\n        var serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n        var saslContinueCmd = {\n          saslContinue: 1,\n          conversationId: r.conversationId,\n          payload: new Binary(Buffer.from(clientFinal))\n        };\n        sendAuthCommand(connection, \"\".concat(db, \".$cmd\"), saslContinueCmd, function (err, r) {\n          if (err || r && typeof r.ok === 'number' && r.ok === 0) {\n            callback(err, r);\n            return;\n          }\n\n          var parsedResponse = parsePayload(r.payload.value());\n\n          if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n            callback(new MongoError('Server returned an invalid signature'));\n            return;\n          }\n\n          if (!r || r.done !== false) {\n            return callback(err, r);\n          }\n\n          var retrySaslContinueCmd = {\n            saslContinue: 1,\n            conversationId: r.conversationId,\n            payload: Buffer.alloc(0)\n          };\n          sendAuthCommand(connection, \"\".concat(db, \".$cmd\"), retrySaslContinueCmd, callback);\n        });\n      });\n    }\n    /**\n     * Implementation of authentication for a single connection\n     * @override\n     */\n\n  }, {\n    key: \"_authenticateSingleConnection\",\n    value: function _authenticateSingleConnection(sendAuthCommand, connection, credentials, callback) {\n      var _this2 = this;\n\n      // Create a random nonce\n      crypto.randomBytes(24, function (err, buff) {\n        if (err) {\n          return callback(err, null);\n        }\n\n        return _this2._executeScram(sendAuthCommand, connection, credentials, buff.toString('base64'), callback);\n      });\n    }\n    /**\n     * Authenticate\n     * @override\n     * @method\n     */\n\n  }, {\n    key: \"auth\",\n    value: function auth(sendAuthCommand, connections, credentials, callback) {\n      this._checkSaslprep();\n\n      _get(_getPrototypeOf(ScramSHA.prototype), \"auth\", this).call(this, sendAuthCommand, connections, credentials, callback);\n    }\n  }, {\n    key: \"_checkSaslprep\",\n    value: function _checkSaslprep() {\n      var cryptoMethod = this.cryptoMethod;\n\n      if (cryptoMethod === 'sha256') {\n        if (!saslprep) {\n          console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n        }\n      }\n    }\n  }], [{\n    key: \"_getError\",\n    value: function _getError(err, r) {\n      if (err) {\n        return err;\n      }\n\n      if (r.$err || r.errmsg) {\n        return new MongoError(r);\n      }\n    }\n  }]);\n\n  return ScramSHA;\n}(AuthProvider);\n/**\n * Creates a new ScramSHA1 authentication mechanism\n * @class\n * @extends ScramSHA\n */\n\n\nvar ScramSHA1 = /*#__PURE__*/function (_ScramSHA) {\n  _inherits(ScramSHA1, _ScramSHA);\n\n  function ScramSHA1(bson) {\n    _classCallCheck(this, ScramSHA1);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA1).call(this, bson, 'sha1'));\n  }\n\n  return ScramSHA1;\n}(ScramSHA);\n/**\n * Creates a new ScramSHA256 authentication mechanism\n * @class\n * @extends ScramSHA\n */\n\n\nvar ScramSHA256 = /*#__PURE__*/function (_ScramSHA2) {\n  _inherits(ScramSHA256, _ScramSHA2);\n\n  function ScramSHA256(bson) {\n    _classCallCheck(this, ScramSHA256);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA256).call(this, bson, 'sha256'));\n  }\n\n  return ScramSHA256;\n}(ScramSHA);\n\nmodule.exports = {\n  ScramSHA1: ScramSHA1,\n  ScramSHA256: ScramSHA256\n};","map":null,"metadata":{},"sourceType":"script"}