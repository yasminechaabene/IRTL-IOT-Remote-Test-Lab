{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar retrieveBSON = require('./connection/utils').retrieveBSON;\n\nvar EventEmitter = require('events');\n\nvar BSON = retrieveBSON();\nvar Binary = BSON.Binary;\n\nvar uuidV4 = require('./utils').uuidV4;\n\nvar MongoError = require('./error').MongoError;\n\nvar isRetryableError = require('././error').isRetryableError;\n\nvar MongoNetworkError = require('./error').MongoNetworkError;\n\nvar MongoWriteConcernError = require('./error').MongoWriteConcernError;\n\nvar Transaction = require('./transactions').Transaction;\n\nvar TxnState = require('./transactions').TxnState;\n\nvar isPromiseLike = require('./utils').isPromiseLike;\n\nvar ReadPreference = require('./topologies/read_preference');\n\nvar isTransactionCommand = require('./transactions').isTransactionCommand;\n\nvar resolveClusterTime = require('./topologies/shared').resolveClusterTime;\n\nvar isSharded = require('./wireprotocol/shared').isSharded;\n\nvar maxWireVersion = require('./utils').maxWireVersion;\n\nvar minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    var error = new MongoError('Cannot use a session that has ended');\n\n    if (typeof callback === 'function') {\n      callback(error, null);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n/**\n * Options to pass when creating a Client Session\n * @typedef {Object} SessionOptions\n * @property {boolean} [causalConsistency=true] Whether causal consistency should be enabled on this session\n * @property {TransactionOptions} [defaultTransactionOptions] The default TransactionOptions to use for transactions started on this session.\n */\n\n/**\n * A BSON document reflecting the lsid of a {@link ClientSession}\n * @typedef {Object} SessionId\n */\n\n/**\n * A class representing a client session on the server\n * WARNING: not meant to be instantiated directly.\n * @class\n * @hideconstructor\n */\n\n\nvar ClientSession = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(ClientSession, _EventEmitter);\n\n  /**\n   * Create a client session.\n   * WARNING: not meant to be instantiated directly\n   *\n   * @param {Topology} topology The current client's topology (Internal Class)\n   * @param {ServerSessionPool} sessionPool The server session pool (Internal Class)\n   * @param {SessionOptions} [options] Optional settings\n   * @param {Object} [clientOptions] Optional settings provided when creating a client in the porcelain driver\n   */\n  function ClientSession(topology, sessionPool, options, clientOptions) {\n    var _this;\n\n    _classCallCheck(this, ClientSession);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClientSession).call(this));\n\n    if (topology == null) {\n      throw new Error('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      throw new Error('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options || {};\n    clientOptions = clientOptions || {};\n    _this.topology = topology;\n    _this.sessionPool = sessionPool;\n    _this.hasEnded = false;\n    _this.serverSession = sessionPool.acquire();\n    _this.clientOptions = clientOptions;\n    _this.supports = {\n      causalConsistency: typeof options.causalConsistency !== 'undefined' ? options.causalConsistency : true\n    };\n    _this.clusterTime = options.initialClusterTime;\n    _this.operationTime = null;\n    _this.explicit = !!options.explicit;\n    _this.owner = options.owner;\n    _this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    _this.transaction = new Transaction();\n    return _this;\n  }\n  /**\n   * The server id associated with this session\n   * @type {SessionId}\n   */\n\n\n  _createClass(ClientSession, [{\n    key: \"endSession\",\n\n    /**\n     * Ends this session on the server\n     *\n     * @param {Object} [options] Optional settings. Currently reserved for future use\n     * @param {Function} [callback] Optional callback for completion of this operation\n     */\n    value: function endSession(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options || {};\n\n      if (this.hasEnded) {\n        if (typeof callback === 'function') callback(null, null);\n        return;\n      }\n\n      if (this.serverSession && this.inTransaction()) {\n        this.abortTransaction(); // pass in callback?\n      } // mark the session as ended, and emit a signal\n\n\n      this.hasEnded = true;\n      this.emit('ended', this); // release the server session back to the pool\n\n      this.sessionPool.release(this.serverSession);\n      this.serverSession = null; // spec indicates that we should ignore all errors for `endSessions`\n\n      if (typeof callback === 'function') callback(null, null);\n    }\n    /**\n     * Advances the operationTime for a ClientSession.\n     *\n     * @param {Timestamp} operationTime the `BSON.Timestamp` of the operation type it is desired to advance to\n     */\n\n  }, {\n    key: \"advanceOperationTime\",\n    value: function advanceOperationTime(operationTime) {\n      if (this.operationTime == null) {\n        this.operationTime = operationTime;\n        return;\n      }\n\n      if (operationTime.greaterThan(this.operationTime)) {\n        this.operationTime = operationTime;\n      }\n    }\n    /**\n     * Used to determine if this session equals another\n     * @param {ClientSession} session\n     * @return {boolean} true if the sessions are equal\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(session) {\n      if (!(session instanceof ClientSession)) {\n        return false;\n      }\n\n      return this.id.id.buffer.equals(session.id.id.buffer);\n    }\n    /**\n     * Increment the transaction number on the internal ServerSession\n     */\n\n  }, {\n    key: \"incrementTransactionNumber\",\n    value: function incrementTransactionNumber() {\n      this.serverSession.txnNumber++;\n    }\n    /**\n     * @returns {boolean} whether this session is currently in a transaction or not\n     */\n\n  }, {\n    key: \"inTransaction\",\n    value: function inTransaction() {\n      return this.transaction.isActive;\n    }\n    /**\n     * Starts a new transaction with the given options.\n     *\n     * @param {TransactionOptions} options Options for the transaction\n     */\n\n  }, {\n    key: \"startTransaction\",\n    value: function startTransaction(options) {\n      assertAlive(this);\n\n      if (this.inTransaction()) {\n        throw new MongoError('Transaction already in progress');\n      }\n\n      var topologyMaxWireVersion = maxWireVersion(this.topology);\n\n      if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n        throw new MongoError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n      } // increment txnNumber\n\n\n      this.incrementTransactionNumber(); // create transaction state\n\n      this.transaction = new Transaction(Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions));\n      this.transaction.transition(TxnState.STARTING_TRANSACTION);\n    }\n    /**\n     * Commits the currently active transaction in this session.\n     *\n     * @param {Function} [callback] optional callback for completion of this operation\n     * @return {Promise} A promise is returned if no callback is provided\n     */\n\n  }, {\n    key: \"commitTransaction\",\n    value: function commitTransaction(callback) {\n      var _this2 = this;\n\n      if (typeof callback === 'function') {\n        endTransaction(this, 'commitTransaction', callback);\n        return;\n      }\n\n      return new Promise(function (resolve, reject) {\n        endTransaction(_this2, 'commitTransaction', function (err, reply) {\n          return err ? reject(err) : resolve(reply);\n        });\n      });\n    }\n    /**\n     * Aborts the currently active transaction in this session.\n     *\n     * @param {Function} [callback] optional callback for completion of this operation\n     * @return {Promise} A promise is returned if no callback is provided\n     */\n\n  }, {\n    key: \"abortTransaction\",\n    value: function abortTransaction(callback) {\n      var _this3 = this;\n\n      if (typeof callback === 'function') {\n        endTransaction(this, 'abortTransaction', callback);\n        return;\n      }\n\n      return new Promise(function (resolve, reject) {\n        endTransaction(_this3, 'abortTransaction', function (err, reply) {\n          return err ? reject(err) : resolve(reply);\n        });\n      });\n    }\n    /**\n     * This is here to ensure that ClientSession is never serialized to BSON.\n     * @ignore\n     */\n\n  }, {\n    key: \"toBSON\",\n    value: function toBSON() {\n      throw new Error('ClientSession cannot be serialized to BSON.');\n    }\n    /**\n     * A user provided function to be run within a transaction\n     *\n     * @callback WithTransactionCallback\n     * @param {ClientSession} session The parent session of the transaction running the operation. This should be passed into each operation within the lambda.\n     * @returns {Promise} The resulting Promise of operations run within this transaction\n     */\n\n    /**\n     * Runs a provided lambda within a transaction, retrying either the commit operation\n     * or entire transaction as needed (and when the error permits) to better ensure that\n     * the transaction can complete successfully.\n     *\n     * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n     * return a Promise will result in undefined behavior.\n     *\n     * @param {WithTransactionCallback} fn\n     * @param {TransactionOptions} [options] Optional settings for the transaction\n     */\n\n  }, {\n    key: \"withTransaction\",\n    value: function withTransaction(fn, options) {\n      var startTime = Date.now();\n      return attemptTransaction(this, startTime, fn, options);\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.serverSession.id;\n    }\n  }]);\n\n  return ClientSession;\n}(EventEmitter);\n\nvar MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nvar UNSATISFIABLE_WRITE_CONCERN_CODE = 100;\nvar UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;\nvar MAX_TIME_MS_EXPIRED_CODE = 50;\nvar NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return Date.now() - startTime < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;\n}\n\nfunction isMaxTimeMSExpiredError(err) {\n  return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(function (err) {\n    if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nvar USER_EXPLICIT_TXN_END_STATES = new Set([TxnState.NO_TRANSACTION, TxnState.TRANSACTION_COMMITTED, TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  session.startTransaction(options);\n  var promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new TypeError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(function () {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }).catch(function (err) {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof MongoError && err.hasErrorLabel('TransientTransactionError') && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        if (err.errorLabels == null) {\n          err.errorLabels = [];\n        }\n\n        err.errorLabels.push('UnknownTransactionCommitResult');\n      }\n\n      throw err;\n    }\n\n    if (session.transaction.isActive) {\n      return session.abortTransaction().then(function () {\n        return maybeRetryOrThrow(err);\n      });\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  } // handle any initial problematic cases\n\n\n  var txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new MongoError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  var command = _defineProperty({}, commandName, 1); // apply a writeConcern if specified\n\n\n  var writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.w) {\n    writeConcern = {\n      w: session.clientOptions.w\n    };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern: writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(e, r) {\n    if (commandName === 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n\n      if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {\n        if (e.errorLabels) {\n          var idx = e.errorLabels.indexOf('TransientTransactionError');\n\n          if (idx !== -1) {\n            e.errorLabels.splice(idx, 1);\n          }\n        } else {\n          e.errorLabels = [];\n        }\n\n        if (isUnknownTransactionCommitResult(e)) {\n          e.errorLabels.push('UnknownTransactionCommitResult'); // per txns spec, must unpin session in this case\n\n          session.transaction.unpinServer();\n        }\n      }\n    } else {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n    }\n\n    callback(e, r);\n  } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n  function transactionError(err) {\n    return commandName === 'commitTransaction' ? err : null;\n  }\n\n  if ( // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n  session.transaction.recoveryToken && supportsRecoveryToken(session)) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  session.topology.command('admin.$cmd', command, {\n    session: session\n  }, function (err, reply) {\n    if (err && isRetryableError(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.transaction.unpinServer();\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return session.topology.command('admin.$cmd', command, {\n        session: session\n      }, function (_err, _reply) {\n        return commandHandler(transactionError(_err), _reply);\n      });\n    }\n\n    commandHandler(transactionError(err), reply);\n  });\n}\n\nfunction supportsRecoveryToken(session) {\n  var topology = session.topology;\n  return !!topology.s.options.useRecoveryToken;\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @ignore\n */\n\n\nvar ServerSession = /*#__PURE__*/function () {\n  function ServerSession() {\n    _classCallCheck(this, ServerSession);\n\n    this.id = {\n      id: new Binary(uuidV4(), Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = Date.now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   * @ignore\n   * @param {Date} sessionTimeoutMinutes The server's \"logicalSessionTimeoutMinutes\"\n   * @return {boolean} true if the session has timed out.\n   */\n\n\n  _createClass(ServerSession, [{\n    key: \"hasTimedOut\",\n    value: function hasTimedOut(sessionTimeoutMinutes) {\n      // Take the difference of the lastUse timestamp and now, which will result in a value in\n      // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n      var idleTimeMinutes = Math.round((Date.now() - this.lastUse) % 86400000 % 3600000 / 60000);\n      return idleTimeMinutes > sessionTimeoutMinutes - 1;\n    }\n  }]);\n\n  return ServerSession;\n}();\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @ignore\n */\n\n\nvar ServerSessionPool = /*#__PURE__*/function () {\n  function ServerSessionPool(topology) {\n    _classCallCheck(this, ServerSessionPool);\n\n    if (topology == null) {\n      throw new Error('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n  /**\n   * Ends all sessions in the session pool.\n   * @ignore\n   */\n\n\n  _createClass(ServerSessionPool, [{\n    key: \"endAllPooledSessions\",\n    value: function endAllPooledSessions(callback) {\n      var _this4 = this;\n\n      if (this.sessions.length) {\n        this.topology.endSessions(this.sessions.map(function (session) {\n          return session.id;\n        }), function () {\n          _this4.sessions = [];\n\n          if (typeof callback === 'function') {\n            callback();\n          }\n        });\n        return;\n      }\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    }\n    /**\n     * Acquire a Server Session from the pool.\n     * Iterates through each session in the pool, removing any stale sessions\n     * along the way. The first non-stale session found is removed from the\n     * pool and returned. If no non-stale session is found, a new ServerSession\n     * is created.\n     * @ignore\n     * @returns {ServerSession}\n     */\n\n  }, {\n    key: \"acquire\",\n    value: function acquire() {\n      var sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n      while (this.sessions.length) {\n        var session = this.sessions.shift();\n\n        if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n          return session;\n        }\n      }\n\n      return new ServerSession();\n    }\n    /**\n     * Release a session to the session pool\n     * Adds the session back to the session pool if the session has not timed out yet.\n     * This method also removes any stale sessions from the pool.\n     * @ignore\n     * @param {ServerSession} session The session to release to the pool\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(session) {\n      var sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n      while (this.sessions.length) {\n        var pooledSession = this.sessions[this.sessions.length - 1];\n\n        if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n          this.sessions.pop();\n        } else {\n          break;\n        }\n      }\n\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        if (session.isDirty) {\n          return;\n        } // otherwise, readd this session to the session pool\n\n\n        this.sessions.unshift(session);\n      }\n    }\n  }]);\n\n  return ServerSessionPool;\n}(); // TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {\n    return true;\n  }\n\n  if (command.mapReduce && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @ignore\n * @param {ClientSession} session the session tracking transaction state\n * @param {Object} command the command to decorate\n * @param {Object} topology the topology for tracking the cluster time\n * @param {Object} [options] Optional settings passed to calling operation\n * @return {MongoError|null} An error, if some error condition was met\n */\n\n\nfunction applySession(session, command, options) {\n  var serverSession = session.serverSession;\n\n  if (serverSession == null) {\n    // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n    return new MongoError('Cannot use a session that has ended');\n  } // mark the last use of this session, and apply the `lsid`\n\n\n  serverSession.lastUse = Date.now();\n  command.lsid = serverSession.id; // first apply non-transaction-specific sessions data\n\n  var inTransaction = session.inTransaction() || isTransactionCommand(command);\n  var isRetryableWrite = options.willRetryWrite;\n  var shouldApplyReadConcern = commandSupportsReadConcern(command);\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\n  } // now attempt to apply transaction-specific sessions data\n\n\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    } // TODO: the following should only be applied to read operation per spec.\n    // for causal consistency\n\n\n    if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n\n    return;\n  }\n\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\n    return new MongoError(\"Read preference in a transaction must be primary, not: \".concat(options.readPreference.mode));\n  } // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    var readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\n\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    resolveClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n}\n\nmodule.exports = {\n  ClientSession: ClientSession,\n  ServerSession: ServerSession,\n  ServerSessionPool: ServerSessionPool,\n  TxnState: TxnState,\n  applySession: applySession,\n  updateSessionFromResponse: updateSessionFromResponse,\n  commandSupportsReadConcern: commandSupportsReadConcern\n};","map":null,"metadata":{},"sourceType":"script"}