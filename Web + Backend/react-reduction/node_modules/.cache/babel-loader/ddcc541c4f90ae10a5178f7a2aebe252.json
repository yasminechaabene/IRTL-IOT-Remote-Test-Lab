{"ast":null,"code":"'use strict';\n\nvar net = require('net');\n\nvar tls = require('tls');\n\nvar Connection = require('./connection');\n\nvar Query = require('./commands').Query;\n\nvar MongoError = require('../error').MongoError;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\n\nvar WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nvar makeClientMetadata = require('../utils').makeClientMetadata;\n\nvar MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nvar MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nvar MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nvar MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nvar AUTH_PROVIDERS;\n\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n\n  var ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  var family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, function (err, socket) {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n\n      return;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction isModernConnectionType(conn) {\n  return typeof conn.command === 'function';\n}\n\nfunction getSaslSupportedMechs(options) {\n  if (!(options && options.credentials)) {\n    return {};\n  }\n\n  var credentials = options.credentials; // TODO: revisit whether or not items like `options.user` and `options.dbName` should be checked here\n\n  var authMechanism = credentials.mechanism;\n  var authSource = credentials.source || options.dbName || 'admin';\n  var user = credentials.username || options.user;\n\n  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') {\n    return {};\n  }\n\n  if (!user) {\n    return {};\n  }\n\n  return {\n    saslSupportedMechs: \"\".concat(authSource, \".\").concat(user)\n  };\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  var serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === 'number' && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  var serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === 'number' && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    var _message = \"Server at \".concat(options.host, \":\").concat(options.port, \" reports minimum wire version \").concat(ismaster.minWireVersion, \", but this version of the Node.js Driver requires at most \").concat(MAX_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(MAX_SUPPORTED_SERVER_VERSION, \")\");\n\n    return new MongoError(_message);\n  }\n\n  var message = \"Server at \".concat(options.host, \":\").concat(options.port, \" reports maximum wire version \").concat(ismaster.maxWireVersion || 0, \", but this version of the Node.js Driver requires at least \").concat(MIN_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(MIN_SUPPORTED_SERVER_VERSION, \")\");\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  var callback = function callback(err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  var compressors = [];\n\n  if (options.compression && options.compression.compressors) {\n    compressors = options.compression.compressors;\n  }\n\n  var handshakeDoc = Object.assign({\n    ismaster: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  }, getSaslSupportedMechs(options));\n  var handshakeOptions = Object.assign({}, options); // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n\n  if (options.connectTimeoutMS || options.connectionTimeout) {\n    handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n  }\n\n  var start = new Date().getTime();\n  runCommand(conn, 'admin.$cmd', handshakeDoc, handshakeOptions, function (err, ismaster) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (ismaster.ok === 0) {\n      callback(new MongoError(ismaster));\n      return;\n    }\n\n    var supportedServerErr = checkSupportedServer(ismaster, options);\n\n    if (supportedServerErr) {\n      callback(supportedServerErr);\n      return;\n    }\n\n    if (!isModernConnectionType(conn)) {\n      // resolve compression\n      if (ismaster.compression) {\n        var agreedCompressors = compressors.filter(function (compressor) {\n          return ismaster.compression.indexOf(compressor) !== -1;\n        });\n\n        if (agreedCompressors.length) {\n          conn.agreedCompressor = agreedCompressors[0];\n        }\n\n        if (options.compression && options.compression.zlibCompressionLevel) {\n          conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n        }\n      }\n    } // NOTE: This is metadata attached to the connection while porting away from\n    //       handshake being done in the `Server` class. Likely, it should be\n    //       relocated, or at very least restructured.\n\n\n    conn.ismaster = ismaster;\n    conn.lastIsMasterMS = new Date().getTime() - start;\n    var credentials = options.credentials;\n\n    if (!ismaster.arbiterOnly && credentials) {\n      credentials.resolveAuthMechanism(ismaster);\n      authenticate(conn, credentials, callback);\n      return;\n    }\n\n    callback(undefined, conn);\n  });\n}\n\nvar LEGAL_SSL_SOCKET_OPTIONS = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize', 'crl', 'rejectUnauthorized'];\n\nfunction parseConnectOptions(family, options) {\n  var host = typeof options.host === 'string' ? options.host : 'localhost';\n\n  if (host.indexOf('/') !== -1) {\n    return {\n      path: host\n    };\n  }\n\n  var result = {\n    family: family,\n    host: host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  var result = parseConnectOptions(family, options); // Merge in valid SSL options\n\n  for (var name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  } // Override checkServerIdentity behavior\n\n\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function () {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nvar SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\n\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  var useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  var keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  var keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n  var noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  var connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 30000;\n  var socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n  var rejectUnauthorized = typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  var socket;\n\n  var callback = function callback(err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  var connectEvent = useSsl ? 'secureConnect' : 'connect';\n  var cancellationHandler;\n\n  function errorHandler(eventName) {\n    return function (err) {\n      SOCKET_ERROR_EVENTS.forEach(function (event) {\n        return socket.removeAllListeners(event);\n      });\n\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(function (event) {\n      return socket.removeAllListeners(event);\n    });\n\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(function (event) {\n    return socket.once(event, errorHandler(event));\n  });\n\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nvar CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\n\nfunction runCommand(conn, ns, command, options, callback) {\n  if (typeof options === 'function') callback = options, options = {}; // are we using the new connection type? if so, no need to simulate a rpc `command` method\n\n  if (isModernConnectionType(conn)) {\n    conn.command(ns, command, options, function (err, result) {\n      if (err) {\n        callback(err);\n        return;\n      } // NODE-2382: raw wire protocol messages, or command results should not be used anymore\n\n\n      callback(undefined, result.result);\n    });\n    return;\n  }\n\n  var socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n  var bson = conn.options.bson;\n  var query = new Query(bson, ns, command, {\n    numberToSkip: 0,\n    numberToReturn: 1\n  });\n\n  var noop = function noop() {};\n\n  function _callback(err, result) {\n    callback(err, result);\n    callback = noop;\n  }\n\n  function errorHandler(err) {\n    conn.resetSocketTimeout();\n    CONNECTION_ERROR_EVENTS.forEach(function (eventName) {\n      return conn.removeListener(eventName, errorHandler);\n    });\n    conn.removeListener('message', messageHandler);\n\n    if (err == null) {\n      err = new MongoError(\"runCommand failed for connection to '\".concat(conn.address, \"'\"));\n    } // ignore all future errors\n\n\n    conn.on('error', noop);\n\n    _callback(err);\n  }\n\n  function messageHandler(msg) {\n    if (msg.responseTo !== query.requestId) {\n      return;\n    }\n\n    conn.resetSocketTimeout();\n    CONNECTION_ERROR_EVENTS.forEach(function (eventName) {\n      return conn.removeListener(eventName, errorHandler);\n    });\n    conn.removeListener('message', messageHandler);\n    msg.parse({\n      promoteValues: true\n    });\n\n    _callback(undefined, msg.documents[0]);\n  }\n\n  conn.setSocketTimeout(socketTimeout);\n  CONNECTION_ERROR_EVENTS.forEach(function (eventName) {\n    return conn.once(eventName, errorHandler);\n  });\n  conn.on('message', messageHandler);\n  conn.write(query.toBin());\n}\n\nfunction authenticate(conn, credentials, callback) {\n  var mechanism = credentials.mechanism;\n\n  if (!AUTH_PROVIDERS[mechanism]) {\n    callback(new MongoError(\"authMechanism '\".concat(mechanism, \"' not supported\")));\n    return;\n  }\n\n  var provider = AUTH_PROVIDERS[mechanism];\n  provider.auth(runCommand, [conn], credentials, function (err) {\n    if (err) return callback(err);\n    callback(undefined, conn);\n  });\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n\n    case 'timeout':\n      return new MongoNetworkError(\"connection timed out\");\n\n    case 'close':\n      return new MongoNetworkError(\"connection closed\");\n\n    case 'cancel':\n      return new MongoNetworkError(\"connection establishment was cancelled\");\n\n    default:\n      return new MongoNetworkError(\"unknown network error\");\n  }\n}\n\nmodule.exports = connect;","map":null,"metadata":{},"sourceType":"script"}