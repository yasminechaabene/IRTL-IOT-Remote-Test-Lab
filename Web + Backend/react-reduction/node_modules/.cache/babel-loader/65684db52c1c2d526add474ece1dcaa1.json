{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar Logger = require('../connection/logger');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar dns = require('dns');\n/**\n * Determines whether a provided address matches the provided parent domain in order\n * to avoid certain attack vectors.\n *\n * @param {String} srvAddress The address to check against a domain\n * @param {String} parentDomain The domain to check the provided address against\n * @return {Boolean} Whether the provided address matches the parent domain\n */\n\n\nfunction matchesParentDomain(srvAddress, parentDomain) {\n  var regex = /^.*?\\./;\n  var srv = \".\".concat(srvAddress.replace(regex, ''));\n  var parent = \".\".concat(parentDomain.replace(regex, ''));\n  return srv.endsWith(parent);\n}\n\nvar SrvPollingEvent = /*#__PURE__*/function () {\n  function SrvPollingEvent(srvRecords) {\n    _classCallCheck(this, SrvPollingEvent);\n\n    this.srvRecords = srvRecords;\n  }\n\n  _createClass(SrvPollingEvent, [{\n    key: \"addresses\",\n    value: function addresses() {\n      return new Set(this.srvRecords.map(function (record) {\n        return \"\".concat(record.name, \":\").concat(record.port);\n      }));\n    }\n  }]);\n\n  return SrvPollingEvent;\n}();\n\nvar SrvPoller = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(SrvPoller, _EventEmitter);\n\n  /**\n   * @param {object} options\n   * @param {string} options.srvHost\n   * @param {number} [options.heartbeatFrequencyMS]\n   * @param {function} [options.logger]\n   * @param {string} [options.loggerLevel]\n   */\n  function SrvPoller(options) {\n    var _this;\n\n    _classCallCheck(this, SrvPoller);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SrvPoller).call(this));\n\n    if (!options || !options.srvHost) {\n      throw new TypeError('options for SrvPoller must exist and include srvHost');\n    }\n\n    _this.srvHost = options.srvHost;\n    _this.rescanSrvIntervalMS = 60000;\n    _this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\n    _this.logger = Logger('srvPoller', options);\n    _this.haMode = false;\n    _this.generation = 0;\n    _this._timeout = null;\n    return _this;\n  }\n\n  _createClass(SrvPoller, [{\n    key: \"start\",\n    value: function start() {\n      if (!this._timeout) {\n        this.schedule();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n        this.generation += 1;\n        this._timeout = null;\n      }\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule() {\n      var _this2 = this;\n\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(function () {\n        return _this2._poll();\n      }, this.intervalMS);\n    }\n  }, {\n    key: \"success\",\n    value: function success(srvRecords) {\n      this.haMode = false;\n      this.schedule();\n      this.emit('srvRecordDiscovery', new SrvPollingEvent(srvRecords));\n    }\n  }, {\n    key: \"failure\",\n    value: function failure(message, obj) {\n      this.logger.warn(message, obj);\n      this.haMode = true;\n      this.schedule();\n    }\n  }, {\n    key: \"parentDomainMismatch\",\n    value: function parentDomainMismatch(srvRecord) {\n      this.logger.warn(\"parent domain mismatch on SRV record (\".concat(srvRecord.name, \":\").concat(srvRecord.port, \")\"), srvRecord);\n    }\n  }, {\n    key: \"_poll\",\n    value: function _poll() {\n      var _this3 = this;\n\n      var generation = this.generation;\n      dns.resolveSrv(this.srvAddress, function (err, srvRecords) {\n        if (generation !== _this3.generation) {\n          return;\n        }\n\n        if (err) {\n          _this3.failure('DNS error', err);\n\n          return;\n        }\n\n        var finalAddresses = [];\n        srvRecords.forEach(function (record) {\n          if (matchesParentDomain(record.name, _this3.srvHost)) {\n            finalAddresses.push(record);\n          } else {\n            _this3.parentDomainMismatch(record);\n          }\n        });\n\n        if (!finalAddresses.length) {\n          _this3.failure('No valid addresses found at host');\n\n          return;\n        }\n\n        _this3.success(finalAddresses);\n      });\n    }\n  }, {\n    key: \"srvAddress\",\n    get: function get() {\n      return \"_mongodb._tcp.\".concat(this.srvHost);\n    }\n  }, {\n    key: \"intervalMS\",\n    get: function get() {\n      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;\n    }\n  }]);\n\n  return SrvPoller;\n}(EventEmitter);\n\nmodule.exports.SrvPollingEvent = SrvPollingEvent;\nmodule.exports.SrvPoller = SrvPoller;","map":null,"metadata":{},"sourceType":"script"}