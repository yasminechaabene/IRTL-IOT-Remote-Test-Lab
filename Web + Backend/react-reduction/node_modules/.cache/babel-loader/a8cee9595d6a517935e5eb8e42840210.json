{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar arrayStrictEqual = require('../utils').arrayStrictEqual;\n\nvar tagsStrictEqual = require('../utils').tagsStrictEqual;\n\nvar errorStrictEqual = require('../utils').errorStrictEqual;\n\nvar ServerType = require('./common').ServerType;\n\nvar WRITABLE_SERVER_TYPES = new Set([ServerType.RSPrimary, ServerType.Standalone, ServerType.Mongos]);\nvar DATA_BEARING_SERVER_TYPES = new Set([ServerType.RSPrimary, ServerType.RSSecondary, ServerType.Mongos, ServerType.Standalone]);\nvar ISMASTER_FIELDS = ['minWireVersion', 'maxWireVersion', 'maxBsonObjectSize', 'maxMessageSizeBytes', 'maxWriteBatchSize', 'compression', 'me', 'hosts', 'passives', 'arbiters', 'tags', 'setName', 'setVersion', 'electionId', 'primary', 'logicalSessionTimeoutMinutes', 'saslSupportedMechs', '__nodejs_mock_server__', '$clusterTime'];\n/**\n * The client's view of a single server, based on the most recent ismaster outcome.\n *\n * Internal type, not meant to be directly instantiated\n */\n\nvar ServerDescription = /*#__PURE__*/function () {\n  /**\n   * Create a ServerDescription\n   * @param {String} address The address of the server\n   * @param {Object} [ismaster] An optional ismaster response for this server\n   * @param {Object} [options] Optional settings\n   * @param {Number} [options.roundTripTime] The round trip time to ping this server (in ms)\n   */\n  function ServerDescription(address, ismaster, options) {\n    var _this = this;\n\n    _classCallCheck(this, ServerDescription);\n\n    options = options || {};\n    ismaster = Object.assign({\n      minWireVersion: 0,\n      maxWireVersion: 0,\n      hosts: [],\n      passives: [],\n      arbiters: [],\n      tags: []\n    }, ismaster);\n    this.address = address;\n    this.error = options.error;\n    this.roundTripTime = options.roundTripTime || -1;\n    this.lastUpdateTime = Date.now();\n    this.lastWriteDate = ismaster.lastWrite ? ismaster.lastWrite.lastWriteDate : null;\n    this.opTime = ismaster.lastWrite ? ismaster.lastWrite.opTime : null;\n    this.type = parseServerType(ismaster); // direct mappings\n\n    ISMASTER_FIELDS.forEach(function (field) {\n      if (typeof ismaster[field] !== 'undefined') _this[field] = ismaster[field];\n    }); // normalize case for hosts\n\n    if (this.me) this.me = this.me.toLowerCase();\n    this.hosts = this.hosts.map(function (host) {\n      return host.toLowerCase();\n    });\n    this.passives = this.passives.map(function (host) {\n      return host.toLowerCase();\n    });\n    this.arbiters = this.arbiters.map(function (host) {\n      return host.toLowerCase();\n    });\n  }\n\n  _createClass(ServerDescription, [{\n    key: \"equals\",\n\n    /**\n     * Determines if another `ServerDescription` is equal to this one per the rules defined\n     * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}\n     *\n     * @param {ServerDescription} other\n     * @return {Boolean}\n     */\n    value: function equals(other) {\n      return other != null && errorStrictEqual(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && this.me === other.me && arrayStrictEqual(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && (this.electionId ? other.electionId && this.electionId.equals(other.electionId) : this.electionId === other.electionId) && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes;\n    }\n  }, {\n    key: \"allHosts\",\n    get: function get() {\n      return this.hosts.concat(this.arbiters).concat(this.passives);\n    }\n    /**\n     * @return {Boolean} Is this server available for reads\n     */\n\n  }, {\n    key: \"isReadable\",\n    get: function get() {\n      return this.type === ServerType.RSSecondary || this.isWritable;\n    }\n    /**\n     * @return {Boolean} Is this server data bearing\n     */\n\n  }, {\n    key: \"isDataBearing\",\n    get: function get() {\n      return DATA_BEARING_SERVER_TYPES.has(this.type);\n    }\n    /**\n     * @return {Boolean} Is this server available for writes\n     */\n\n  }, {\n    key: \"isWritable\",\n    get: function get() {\n      return WRITABLE_SERVER_TYPES.has(this.type);\n    }\n  }]);\n\n  return ServerDescription;\n}();\n/**\n * Parses an `ismaster` message and determines the server type\n *\n * @param {Object} ismaster The `ismaster` message to parse\n * @return {ServerType}\n */\n\n\nfunction parseServerType(ismaster) {\n  if (!ismaster || !ismaster.ok) {\n    return ServerType.Unknown;\n  }\n\n  if (ismaster.isreplicaset) {\n    return ServerType.RSGhost;\n  }\n\n  if (ismaster.msg && ismaster.msg === 'isdbgrid') {\n    return ServerType.Mongos;\n  }\n\n  if (ismaster.setName) {\n    if (ismaster.hidden) {\n      return ServerType.RSOther;\n    } else if (ismaster.ismaster) {\n      return ServerType.RSPrimary;\n    } else if (ismaster.secondary) {\n      return ServerType.RSSecondary;\n    } else if (ismaster.arbiterOnly) {\n      return ServerType.RSArbiter;\n    } else {\n      return ServerType.RSOther;\n    }\n  }\n\n  return ServerType.Standalone;\n}\n\nmodule.exports = {\n  ServerDescription: ServerDescription,\n  parseServerType: parseServerType\n};","map":null,"metadata":{},"sourceType":"script"}