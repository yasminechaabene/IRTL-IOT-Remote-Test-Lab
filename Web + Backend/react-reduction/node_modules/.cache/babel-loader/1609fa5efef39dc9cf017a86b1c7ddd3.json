{"ast":null,"code":"'use strict';\n\nvar applyWriteConcern = require('../utils').applyWriteConcern;\n\nvar Code = require('../core').BSON.Code;\n\nvar resolveReadPreference = require('../utils').resolveReadPreference;\n\nvar crypto = require('crypto');\n\nvar debugOptions = require('../utils').debugOptions;\n\nvar handleCallback = require('../utils').handleCallback;\n\nvar MongoError = require('../core').MongoError;\n\nvar parseIndexOptions = require('../utils').parseIndexOptions;\n\nvar ReadPreference = require('../core').ReadPreference;\n\nvar toError = require('../utils').toError;\n\nvar CONSTANTS = require('../constants');\n\nvar MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nvar count = require('./collection_ops').count;\n\nvar findOne = require('./collection_ops').findOne;\n\nvar remove = require('./collection_ops').remove;\n\nvar updateOne = require('./collection_ops').updateOne;\n\nvar collection;\n\nfunction loadCollection() {\n  if (!collection) {\n    collection = require('../collection');\n  }\n\n  return collection;\n}\n\nvar db;\n\nfunction loadDb() {\n  if (!db) {\n    db = require('../db');\n  }\n\n  return db;\n}\n\nvar debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId', 'serializeFunctions', 'raw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds', 'readPreference', 'pkFactory', 'parentDb', 'promiseLibrary', 'noListener'];\n/**\n * Add a user to the database.\n * @method\n * @param {Db} db The Db instance on which to add a user.\n * @param {string} username The username.\n * @param {string} password The password.\n * @param {object} [options] Optional settings. See Db.prototype.addUser for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\nfunction addUser(db, username, password, options, callback) {\n  var Db = loadDb(); // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Attempt to execute auth command\n\n  executeAuthCreateUserCommand(db, username, password, options, function (err, r) {\n    // We need to perform the backward compatible insert operation\n    if (err && err.code === -5000) {\n      var finalOptions = applyWriteConcern(Object.assign({}, options), {\n        db: db\n      }, options); // Use node md5 generator\n\n      var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n      md5.update(username + ':mongo:' + password);\n      var userPassword = md5.digest('hex'); // If we have another db set\n\n      var dbToUse = options.dbName ? new Db(options.dbName, db.s.topology, db.s.options) : db; // Fetch a user collection\n\n      var _collection = dbToUse.collection(CONSTANTS.SYSTEM_USER_COLLECTION); // Check if we are inserting the first user\n\n\n      count(_collection, {}, finalOptions, function (err, count) {\n        // We got an error (f.ex not authorized)\n        if (err != null) return handleCallback(callback, err, null); // Check if the user exists and update i\n\n        var findOptions = Object.assign({\n          projection: {\n            dbName: 1\n          }\n        }, finalOptions);\n\n        _collection.find({\n          user: username\n        }, findOptions).toArray(function (err) {\n          // We got an error (f.ex not authorized)\n          if (err != null) return handleCallback(callback, err, null); // Add command keys\n\n          finalOptions.upsert = true; // We have a user, let's update the password or upsert if not\n\n          updateOne(_collection, {\n            user: username\n          }, {\n            $set: {\n              user: username,\n              pwd: userPassword\n            }\n          }, finalOptions, function (err) {\n            if (count === 0 && err) return handleCallback(callback, null, [{\n              user: username,\n              pwd: userPassword\n            }]);\n            if (err) return handleCallback(callback, err, null);\n            handleCallback(callback, null, [{\n              user: username,\n              pwd: userPassword\n            }]);\n          });\n        });\n      });\n      return;\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, err, r);\n  });\n}\n/**\n * Fetch all collections for the current db.\n *\n * @method\n * @param {Db} db The Db instance on which to fetch collections.\n * @param {object} [options] Optional settings. See Db.prototype.collections for a list of options.\n * @param {Db~collectionsResultCallback} [callback] The results callback\n */\n\n\nfunction collections(db, options, callback) {\n  var Collection = loadCollection();\n  options = Object.assign({}, options, {\n    nameOnly: true\n  }); // Let's get the collection names\n\n  db.listCollections({}, options).toArray(function (err, documents) {\n    if (err != null) return handleCallback(callback, err, null); // Filter collections removing any illegal ones\n\n    documents = documents.filter(function (doc) {\n      return doc.name.indexOf('$') === -1;\n    }); // Return the collection objects\n\n    handleCallback(callback, null, documents.map(function (d) {\n      return new Collection(db, db.s.topology, db.databaseName, d.name, db.s.pkFactory, db.s.options);\n    }));\n  });\n}\n/**\n * Creates an index on the db and collection.\n * @method\n * @param {Db} db The Db instance on which to create an index.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction createIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  var finalOptions = Object.assign({}, {\n    readPreference: ReadPreference.PRIMARY\n  }, options);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: db\n  }, options); // Ensure we have a callback\n\n  if (finalOptions.writeConcern && typeof callback !== 'function') {\n    throw MongoError.create({\n      message: 'Cannot use a writeConcern without a provided callback',\n      driver: true\n    });\n  } // Did the user destroy the topology\n\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Attempt to run using createIndexes command\n\n  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, function (err, result) {\n    if (err == null) return handleCallback(callback, err, result);\n    /**\n     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:\n     * 67 = 'CannotCreateIndex' (malformed index options)\n     * 85 = 'IndexOptionsConflict' (index already exists with different options)\n     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)\n     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)\n     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)\n     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)\n     */\n\n    if (err.code === 67 || err.code === 11000 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {\n      return handleCallback(callback, err, result);\n    } // Create command\n\n\n    var doc = createCreateIndexCommand(db, name, fieldOrSpec, options); // Set no key checking\n\n    finalOptions.checkKeys = false; // Insert document\n\n    db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, function (err, result) {\n      if (callback == null) return;\n      if (err) return handleCallback(callback, err);\n      if (result == null) return handleCallback(callback, null, null);\n      if (result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);\n      handleCallback(callback, null, doc.name);\n    });\n  });\n} // Add listeners to topology\n\n\nfunction createListener(db, e, object) {\n  function listener(err) {\n    if (object.listeners(e).length > 0) {\n      object.emit(e, err, db); // Emit on all associated db's if available\n\n      for (var i = 0; i < db.s.children.length; i++) {\n        db.s.children[i].emit(e, err, db.s.children[i]);\n      }\n    }\n  }\n\n  return listener;\n}\n/**\n * Drop a collection from the database, removing it permanently. New accesses will create a new collection.\n *\n * @method\n * @param {Db} db The Db instance on which to drop the collection.\n * @param {string} name Name of collection to drop\n * @param {Object} [options] Optional settings. See Db.prototype.dropCollection for a list of options.\n * @param {Db~resultCallback} [callback] The results callback\n */\n\n\nfunction dropCollection(db, name, options, callback) {\n  executeCommand(db, name, options, function (err, result) {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (err) return handleCallback(callback, err);\n    if (result.ok) return handleCallback(callback, null, true);\n    handleCallback(callback, null, false);\n  });\n}\n/**\n * Drop a database, removing it permanently from the server.\n *\n * @method\n * @param {Db} db The Db instance to drop.\n * @param {Object} cmd The command document.\n * @param {Object} [options] Optional settings. See Db.prototype.dropDatabase for a list of options.\n * @param {Db~resultCallback} [callback] The results callback\n */\n\n\nfunction dropDatabase(db, cmd, options, callback) {\n  executeCommand(db, cmd, options, function (err, result) {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result.ok ? true : false);\n  });\n}\n/**\n * Ensures that an index exists. If it does not, creates it.\n *\n * @method\n * @param {Db} db The Db instance on which to ensure the index.\n * @param {string} name The index name\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings. See Db.prototype.ensureIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction ensureIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  var finalOptions = applyWriteConcern({}, {\n    db: db\n  }, options); // Create command\n\n  var selector = createCreateIndexCommand(db, name, fieldOrSpec, options);\n  var index_name = selector.name; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Merge primary readPreference\n\n  finalOptions.readPreference = ReadPreference.PRIMARY; // Check if the index already exists\n\n  indexInformation(db, name, finalOptions, function (err, indexInformation) {\n    if (err != null && err.code !== 26) return handleCallback(callback, err, null); // If the index does not exist, create it\n\n    if (indexInformation == null || !indexInformation[index_name]) {\n      createIndex(db, name, fieldOrSpec, options, callback);\n    } else {\n      if (typeof callback === 'function') return handleCallback(callback, null, index_name);\n    }\n  });\n}\n/**\n * Evaluate JavaScript on the server\n *\n * @method\n * @param {Db} db The Db instance.\n * @param {Code} code JavaScript to execute on server.\n * @param {(object|array)} parameters The parameters for the call.\n * @param {object} [options] Optional settings. See Db.prototype.eval for a list of options.\n * @param {Db~resultCallback} [callback] The results callback\n * @deprecated Eval is deprecated on MongoDB 3.2 and forward\n */\n\n\nfunction evaluate(db, code, parameters, options, callback) {\n  var finalCode = code;\n  var finalParameters = []; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // If not a code object translate to one\n\n  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode); // Ensure the parameters are correct\n\n  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = [parameters];\n  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = parameters;\n  } // Create execution selector\n\n\n  var cmd = {\n    $eval: finalCode,\n    args: finalParameters\n  }; // Check if the nolock parameter is passed in\n\n  if (options['nolock']) {\n    cmd['nolock'] = options['nolock'];\n  } // Set primary read preference\n\n\n  options.readPreference = new ReadPreference(ReadPreference.PRIMARY); // Execute the command\n\n  executeCommand(db, cmd, options, function (err, result) {\n    if (err) return handleCallback(callback, err, null);\n    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);\n    if (result) return handleCallback(callback, MongoError.create({\n      message: \"eval failed: \".concat(result.errmsg),\n      driver: true\n    }), null);\n    handleCallback(callback, err, result);\n  });\n}\n/**\n * Execute a command\n *\n * @method\n * @param {Db} db The Db instance on which to execute the command.\n * @param {object} command The command hash\n * @param {object} [options] Optional settings. See Db.prototype.command for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction executeCommand(db, command, options, callback) {\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Get the db name we are executing against\n\n  var dbName = options.dbName || options.authdb || db.databaseName; // Convert the readPreference if its not a write\n\n  options.readPreference = resolveReadPreference(db, options); // Debug information\n\n  if (db.s.logger.isDebug()) db.s.logger.debug(\"executing command \".concat(JSON.stringify(command), \" against \").concat(dbName, \".$cmd with options [\").concat(JSON.stringify(debugOptions(debugFields, options)), \"]\")); // Execute command\n\n  db.s.topology.command(db.s.namespace.withCollection('$cmd'), command, options, function (err, result) {\n    if (err) return handleCallback(callback, err);\n    if (options.full) return handleCallback(callback, null, result);\n    handleCallback(callback, null, result.result);\n  });\n}\n/**\n * Runs a command on the database as admin.\n *\n * @method\n * @param {Db} db The Db instance on which to execute the command.\n * @param {object} command The command hash\n * @param {object} [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction executeDbAdminCommand(db, command, options, callback) {\n  var namespace = new MongoDBNamespace('admin', '$cmd');\n  db.s.topology.command(namespace, command, options, function (err, result) {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.result);\n  });\n}\n/**\n * Retrieves this collections index info.\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the index info.\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  var full = options['full'] == null ? false : options['full']; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    var info = {}; // Process all the indexes\n\n    for (var i = 0; i < indexes.length; i++) {\n      var index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (var _name in index.key) {\n        info[index.name].push([_name, index.key[_name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray(function (err, indexes) {\n    if (err) return callback(toError(err));\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n    if (full) return handleCallback(callback, null, indexes);\n    handleCallback(callback, null, processResults(indexes));\n  });\n}\n/**\n * Retrieve the current profiling information for MongoDB\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the profiling info.\n * @param {Object} [options] Optional settings. See Db.protoype.profilingInfo for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback.\n * @deprecated Query the system.profile collection directly.\n */\n\n\nfunction profilingInfo(db, options, callback) {\n  try {\n    db.collection('system.profile').find({}, options).toArray(callback);\n  } catch (err) {\n    return callback(err, null);\n  }\n}\n/**\n * Remove a user from a database\n *\n * @method\n * @param {Db} db The Db instance on which to remove the user.\n * @param {string} username The username.\n * @param {object} [options] Optional settings. See Db.prototype.removeUser for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction removeUser(db, username, options, callback) {\n  var Db = loadDb(); // Attempt to execute command\n\n  executeAuthRemoveUserCommand(db, username, options, function (err, result) {\n    if (err && err.code === -5000) {\n      var finalOptions = applyWriteConcern(Object.assign({}, options), {\n        db: _db\n      }, options); // If we have another db set\n\n      var _db = options.dbName ? new Db(options.dbName, _db.s.topology, _db.s.options) : _db; // Fetch a user collection\n\n\n      var _collection2 = _db.collection(CONSTANTS.SYSTEM_USER_COLLECTION); // Locate the user\n\n\n      findOne(_collection2, {\n        user: username\n      }, finalOptions, function (err, user) {\n        if (user == null) return handleCallback(callback, err, false);\n        remove(_collection2, {\n          user: username\n        }, finalOptions, function (err) {\n          handleCallback(callback, err, true);\n        });\n      });\n      return;\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, err, result);\n  });\n} // Validate the database name\n\n\nfunction validateDatabaseName(databaseName) {\n  if (typeof databaseName !== 'string') throw MongoError.create({\n    message: 'database name must be a string',\n    driver: true\n  });\n  if (databaseName.length === 0) throw MongoError.create({\n    message: 'database name cannot be the empty string',\n    driver: true\n  });\n  if (databaseName === '$external') return;\n  var invalidChars = [' ', '.', '$', '/', '\\\\'];\n\n  for (var i = 0; i < invalidChars.length; i++) {\n    if (databaseName.indexOf(invalidChars[i]) !== -1) throw MongoError.create({\n      message: \"database names cannot contain the character '\" + invalidChars[i] + \"'\",\n      driver: true\n    });\n  }\n}\n/**\n * Create the command object for Db.prototype.createIndex.\n *\n * @param {Db} db The Db instance on which to create the command.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @return {Object} The insert command object.\n */\n\n\nfunction createCreateIndexCommand(db, name, fieldOrSpec, options) {\n  var indexParameters = parseIndexOptions(fieldOrSpec);\n  var fieldHash = indexParameters.fieldHash; // Generate the index name\n\n  var indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\n  var selector = {\n    ns: db.s.namespace.withCollection(name).toString(),\n    key: fieldHash,\n    name: indexName\n  }; // Ensure we have a correct finalUnique\n\n  var finalUnique = options == null || 'object' === typeof options ? false : options; // Set up options\n\n  options = options == null || typeof options === 'boolean' ? {} : options; // Add all the options\n\n  var keysToOmit = Object.keys(selector);\n\n  for (var optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      selector[optionName] = options[optionName];\n    }\n  }\n\n  if (selector['unique'] == null) selector['unique'] = finalUnique; // Remove any write concern operations\n\n  var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];\n\n  for (var i = 0; i < removeKeys.length; i++) {\n    delete selector[removeKeys[i]];\n  } // Return the command creation selector\n\n\n  return selector;\n}\n/**\n * Create index using the createIndexes command.\n *\n * @param {Db} db The Db instance on which to execute the command.\n * @param {string} name Name of the collection to create the index on.\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback.\n */\n\n\nfunction createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {\n  // Build the index\n  var indexParameters = parseIndexOptions(fieldOrSpec); // Generate the index name\n\n  var indexName = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  var indexes = [{\n    name: indexName,\n    key: indexParameters.fieldHash\n  }]; // merge all the options\n\n  var keysToOmit = Object.keys(indexes[0]).concat(['writeConcern', 'w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session']);\n\n  for (var optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      indexes[0][optionName] = options[optionName];\n    }\n  } // Get capabilities\n\n\n  var capabilities = db.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {\n    // Create a new error\n    var error = new MongoError('server/primary/mongos does not support collation');\n    error.code = 67; // Return the error\n\n    return callback(error);\n  } // Create command, apply write concern to command\n\n\n  var cmd = applyWriteConcern({\n    createIndexes: name,\n    indexes: indexes\n  }, {\n    db: db\n  }, options); // ReadPreference primary\n\n  options.readPreference = ReadPreference.PRIMARY; // Build the command\n\n  executeCommand(db, cmd, options, function (err, result) {\n    if (err) return handleCallback(callback, err, null);\n    if (result.ok === 0) return handleCallback(callback, toError(result), null); // Return the indexName for backward compatibility\n\n    handleCallback(callback, null, indexName);\n  });\n}\n/**\n * Run the createUser command.\n *\n * @param {Db} db The Db instance on which to execute the command.\n * @param {string} username The username of the user to add.\n * @param {string} password The password of the user to add.\n * @param {object} [options] Optional settings. See Db.prototype.addUser for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction executeAuthCreateUserCommand(db, username, password, options, callback) {\n  // Special case where there is no password ($external users)\n  if (typeof username === 'string' && password != null && typeof password === 'object') {\n    options = password;\n    password = null;\n  } // Unpack all options\n\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  } // Error out if we digestPassword set\n\n\n  if (options.digestPassword != null) {\n    return callback(toError(\"The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option.\"));\n  } // Get additional values\n\n\n  var customData = options.customData != null ? options.customData : {};\n  var roles = Array.isArray(options.roles) ? options.roles : [];\n  var maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null; // If not roles defined print deprecated message\n\n  if (roles.length === 0) {\n    console.log('Creating a user without roles is deprecated in MongoDB >= 2.6');\n  } // Get the error options\n\n\n  var commandOptions = {\n    writeCommand: true\n  };\n  if (options['dbName']) commandOptions.dbName = options['dbName']; // Add maxTimeMS to options if set\n\n  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS; // Check the db name and add roles if needed\n\n  if ((db.databaseName.toLowerCase() === 'admin' || options.dbName === 'admin') && !Array.isArray(options.roles)) {\n    roles = ['root'];\n  } else if (!Array.isArray(options.roles)) {\n    roles = ['dbOwner'];\n  }\n\n  var digestPassword = db.s.topology.lastIsMaster().maxWireVersion >= 7; // Build the command to execute\n\n  var command = {\n    createUser: username,\n    customData: customData,\n    roles: roles,\n    digestPassword: digestPassword\n  }; // Apply write concern to command\n\n  command = applyWriteConcern(command, {\n    db: db\n  }, options);\n  var userPassword = password;\n\n  if (!digestPassword) {\n    // Use node md5 generator\n    var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n    md5.update(username + ':mongo:' + password);\n    userPassword = md5.digest('hex');\n  } // No password\n\n\n  if (typeof password === 'string') {\n    command.pwd = userPassword;\n  } // Force write using primary\n\n\n  commandOptions.readPreference = ReadPreference.primary; // Execute the command\n\n  executeCommand(db, command, commandOptions, function (err, result) {\n    if (err && err.ok === 0 && err.code === undefined) return handleCallback(callback, {\n      code: -5000\n    }, null);\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, !result.ok ? toError(result) : null, result.ok ? [{\n      user: username,\n      pwd: ''\n    }] : null);\n  });\n}\n/**\n * Run the dropUser command.\n *\n * @param {Db} db The Db instance on which to execute the command.\n * @param {string} username The username of the user to remove.\n * @param {object} [options] Optional settings. See Db.prototype.removeUser for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction executeAuthRemoveUserCommand(db, username, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Get the error options\n\n  var commandOptions = {\n    writeCommand: true\n  };\n  if (options['dbName']) commandOptions.dbName = options['dbName']; // Get additional values\n\n  var maxTimeMS = typeof options.maxTimeMS === 'number' ? options.maxTimeMS : null; // Add maxTimeMS to options if set\n\n  if (maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS; // Build the command to execute\n\n  var command = {\n    dropUser: username\n  }; // Apply write concern to command\n\n  command = applyWriteConcern(command, {\n    db: db\n  }, options); // Force write using primary\n\n  commandOptions.readPreference = ReadPreference.primary; // Execute the command\n\n  executeCommand(db, command, commandOptions, function (err, result) {\n    if (err && !err.ok && err.code === undefined) return handleCallback(callback, {\n      code: -5000\n    });\n    if (err) return handleCallback(callback, err, null);\n    handleCallback(callback, null, result.ok ? true : false);\n  });\n}\n\nmodule.exports = {\n  addUser: addUser,\n  collections: collections,\n  createListener: createListener,\n  createIndex: createIndex,\n  dropCollection: dropCollection,\n  dropDatabase: dropDatabase,\n  ensureIndex: ensureIndex,\n  evaluate: evaluate,\n  executeCommand: executeCommand,\n  executeDbAdminCommand: executeDbAdminCommand,\n  indexInformation: indexInformation,\n  profilingInfo: profilingInfo,\n  removeUser: removeUser,\n  validateDatabaseName: validateDatabaseName\n};","map":null,"metadata":{},"sourceType":"script"}