{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar Msg = require('../connection/msg').Msg;\n\nvar KillCursor = require('../connection/commands').KillCursor;\n\nvar GetMore = require('../connection/commands').GetMore;\n\nvar calculateDurationInMs = require('../utils').calculateDurationInMs;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\n\nvar SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']); // helper methods\n\nvar extractCommandName = function extractCommandName(commandDoc) {\n  return Object.keys(commandDoc)[0];\n};\n\nvar namespace = function namespace(command) {\n  return command.ns;\n};\n\nvar databaseName = function databaseName(command) {\n  return command.ns.split('.')[0];\n};\n\nvar collectionName = function collectionName(command) {\n  return command.ns.split('.')[1];\n};\n\nvar generateConnectionId = function generateConnectionId(pool) {\n  return pool.options ? \"\".concat(pool.options.host, \":\").concat(pool.options.port) : pool.address;\n};\n\nvar maybeRedact = function maybeRedact(commandName, result) {\n  return SENSITIVE_COMMANDS.has(commandName) ? {} : result;\n};\n\nvar isLegacyPool = function isLegacyPool(pool) {\n  return pool.s && pool.queue;\n};\n\nvar LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nvar LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\nvar OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\n\nvar extractCommand = function extractCommand(command) {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    var result;\n\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(function (key) {\n        if (typeof command.query[key] !== 'undefined') result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(function (key) {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n    OP_QUERY_KEYS.forEach(function (key) {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nvar extractReply = function extractReply(command, reply) {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  } // is this a legacy find command?\n\n\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  }\n\n  return reply && reply.result ? reply.result : reply;\n};\n\nvar extractConnectionDetails = function extractConnectionDetails(pool) {\n  if (isLegacyPool(pool)) {\n    return {\n      connectionId: generateConnectionId(pool)\n    };\n  } // APM in the modern pool is done at the `Connection` level, so we rename it here for\n  // readability.\n\n\n  var connection = pool;\n  return {\n    address: connection.address,\n    connectionId: connection.id\n  };\n};\n/** An event indicating the start of a given command */\n\n\nvar CommandStartedEvent =\n/**\n * Create a started event\n *\n * @param {Pool} pool the pool that originated the command\n * @param {Object} command the command\n */\nfunction CommandStartedEvent(pool, command) {\n  _classCallCheck(this, CommandStartedEvent);\n\n  var cmd = extractCommand(command);\n  var commandName = extractCommandName(cmd);\n  var connectionDetails = extractConnectionDetails(pool); // NOTE: remove in major revision, this is not spec behavior\n\n  if (SENSITIVE_COMMANDS.has(commandName)) {\n    this.commandObj = {};\n    this.commandObj[commandName] = true;\n  }\n\n  Object.assign(this, connectionDetails, {\n    requestId: command.requestId,\n    databaseName: databaseName(command),\n    commandName: commandName,\n    command: cmd\n  });\n};\n/** An event indicating the success of a given command */\n\n\nvar CommandSucceededEvent =\n/**\n * Create a succeeded event\n *\n * @param {Pool} pool the pool that originated the command\n * @param {Object} command the command\n * @param {Object} reply the reply for this command from the server\n * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n */\nfunction CommandSucceededEvent(pool, command, reply, started) {\n  _classCallCheck(this, CommandSucceededEvent);\n\n  var cmd = extractCommand(command);\n  var commandName = extractCommandName(cmd);\n  var connectionDetails = extractConnectionDetails(pool);\n  Object.assign(this, connectionDetails, {\n    requestId: command.requestId,\n    commandName: commandName,\n    duration: calculateDurationInMs(started),\n    reply: maybeRedact(commandName, extractReply(command, reply))\n  });\n};\n/** An event indicating the failure of a given command */\n\n\nvar CommandFailedEvent =\n/**\n * Create a failure event\n *\n * @param {Pool} pool the pool that originated the command\n * @param {Object} command the command\n * @param {MongoError|Object} error the generated error or a server error response\n * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n */\nfunction CommandFailedEvent(pool, command, error, started) {\n  _classCallCheck(this, CommandFailedEvent);\n\n  var cmd = extractCommand(command);\n  var commandName = extractCommandName(cmd);\n  var connectionDetails = extractConnectionDetails(pool);\n  Object.assign(this, connectionDetails, {\n    requestId: command.requestId,\n    commandName: commandName,\n    duration: calculateDurationInMs(started),\n    failure: maybeRedact(commandName, error)\n  });\n};\n\nmodule.exports = {\n  CommandStartedEvent: CommandStartedEvent,\n  CommandSucceededEvent: CommandSucceededEvent,\n  CommandFailedEvent: CommandFailedEvent\n};","map":null,"metadata":{},"sourceType":"script"}