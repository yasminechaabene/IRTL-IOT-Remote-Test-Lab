{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _defineProperty = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _makeStateMachine;\n\nvar EventEmitter = require('events');\n\nvar ConnectionPool = require('../../cmap/connection_pool').ConnectionPool;\n\nvar CMAP_EVENT_NAMES = require('../../cmap/events').CMAP_EVENT_NAMES;\n\nvar MongoError = require('../error').MongoError;\n\nvar relayEvents = require('../utils').relayEvents;\n\nvar BSON = require('../connection/utils').retrieveBSON();\n\nvar Logger = require('../connection/logger');\n\nvar ServerDescription = require('./server_description').ServerDescription;\n\nvar ReadPreference = require('../topologies/read_preference');\n\nvar Monitor = require('./monitor').Monitor;\n\nvar MongoNetworkError = require('../error').MongoNetworkError;\n\nvar collationNotSupported = require('../utils').collationNotSupported;\n\nvar debugOptions = require('../connection/utils').debugOptions;\n\nvar isSDAMUnrecoverableError = require('../error').isSDAMUnrecoverableError;\n\nvar isNetworkTimeoutError = require('../error').isNetworkTimeoutError;\n\nvar isNodeShuttingDownError = require('../error').isNodeShuttingDownError;\n\nvar maxWireVersion = require('../utils').maxWireVersion;\n\nvar makeStateMachine = require('../utils').makeStateMachine;\n\nvar common = require('./common'); // Used for filtering out fields for logging\n\n\nvar DEBUG_FIELDS = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'servername'];\nvar STATE_CLOSING = common.STATE_CLOSING;\nvar STATE_CLOSED = common.STATE_CLOSED;\nvar STATE_CONNECTING = common.STATE_CONNECTING;\nvar STATE_CONNECTED = common.STATE_CONNECTED;\nvar stateTransition = makeStateMachine((_makeStateMachine = {}, _defineProperty(_makeStateMachine, STATE_CLOSED, [STATE_CLOSED, STATE_CONNECTING]), _defineProperty(_makeStateMachine, STATE_CONNECTING, [STATE_CONNECTING, STATE_CLOSING, STATE_CONNECTED, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CONNECTED, [STATE_CONNECTED, STATE_CLOSING, STATE_CLOSED]), _defineProperty(_makeStateMachine, STATE_CLOSING, [STATE_CLOSING, STATE_CLOSED]), _makeStateMachine));\nvar kMonitor = Symbol('monitor');\n/**\n *\n * @fires Server#serverHeartbeatStarted\n * @fires Server#serverHeartbeatSucceeded\n * @fires Server#serverHeartbeatFailed\n */\n\nvar Server = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Server, _EventEmitter);\n\n  /**\n   * Create a server\n   *\n   * @param {ServerDescription} description\n   * @param {Object} options\n   */\n  function Server(description, options, topology) {\n    var _this;\n\n    _classCallCheck(this, Server);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));\n    _this.s = {\n      // the server description\n      description: description,\n      // a saved copy of the incoming options\n      options: options,\n      // the server logger\n      logger: Logger('Server', options),\n      // the bson parser\n      bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),\n      // the server state\n      state: STATE_CLOSED,\n      credentials: options.credentials,\n      topology: topology\n    }; // create the connection pool\n    // NOTE: this used to happen in `connect`, we supported overriding pool options there\n\n    var addressParts = _this.description.address.split(':');\n\n    var poolOptions = Object.assign({\n      host: addressParts[0],\n      port: parseInt(addressParts[1], 10),\n      bson: _this.s.bson\n    }, options);\n    _this.s.pool = new ConnectionPool(poolOptions);\n    relayEvents(_this.s.pool, _assertThisInitialized(_assertThisInitialized(_this)), ['commandStarted', 'commandSucceeded', 'commandFailed'].concat(CMAP_EVENT_NAMES));\n\n    _this.s.pool.on('clusterTimeReceived', function (clusterTime) {\n      _this.clusterTime = clusterTime;\n    }); // create the monitor\n\n\n    _this[kMonitor] = new Monitor(_assertThisInitialized(_assertThisInitialized(_this)), _this.s.options);\n    relayEvents(_this[kMonitor], _assertThisInitialized(_assertThisInitialized(_this)), ['serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', // legacy events\n    'monitoring']);\n\n    _this[kMonitor].on('resetConnectionPool', function () {\n      _this.s.pool.clear();\n    });\n\n    _this[kMonitor].on('resetServer', function (error) {\n      return markServerUnknown(_assertThisInitialized(_assertThisInitialized(_this)), error);\n    });\n\n    _this[kMonitor].on('serverHeartbeatSucceeded', function (event) {\n      _this.emit('descriptionReceived', new ServerDescription(_this.description.address, event.reply, {\n        roundTripTime: calculateRoundTripTime(_this.description.roundTripTime, event.duration)\n      }));\n\n      if (_this.s.state === STATE_CONNECTING) {\n        stateTransition(_assertThisInitialized(_assertThisInitialized(_this)), STATE_CONNECTED);\n\n        _this.emit('connect', _assertThisInitialized(_assertThisInitialized(_this)));\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(Server, [{\n    key: \"connect\",\n\n    /**\n     * Initiate server connect\n     */\n    value: function connect() {\n      if (this.s.state !== STATE_CLOSED) {\n        return;\n      }\n\n      stateTransition(this, STATE_CONNECTING);\n      this[kMonitor].connect();\n    }\n    /**\n     * Destroy the server connection\n     *\n     * @param {object} [options] Optional settings\n     * @param {Boolean} [options.force=false] Force destroy the pool\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      var _this2 = this;\n\n      if (typeof options === 'function') callback = options, options = {};\n      options = Object.assign({}, {\n        force: false\n      }, options);\n\n      if (this.s.state === STATE_CLOSED) {\n        if (typeof callback === 'function') {\n          callback();\n        }\n\n        return;\n      }\n\n      stateTransition(this, STATE_CLOSING);\n      this[kMonitor].close();\n      this.s.pool.close(options, function (err) {\n        stateTransition(_this2, STATE_CLOSED);\n\n        _this2.emit('closed');\n\n        if (typeof callback === 'function') {\n          callback(err);\n        }\n      });\n    }\n    /**\n     * Immediately schedule monitoring of this server. If there already an attempt being made\n     * this will be a no-op.\n     */\n\n  }, {\n    key: \"requestCheck\",\n    value: function requestCheck() {\n      this[kMonitor].requestCheck();\n    }\n    /**\n     * Execute a command\n     *\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {object} cmd The command hash\n     * @param {object} [options] Optional settings\n     * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n     * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.\n     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n     * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n     * @param {ClientSession} [options.session] Session to use for the operation\n     * @param {opResultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options, options = {}, options = options || {};\n      }\n\n      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n        callback(new MongoError('server is closed'));\n        return;\n      }\n\n      var error = basicReadValidations(this, options);\n\n      if (error) {\n        return callback(error);\n      } // Clone the options\n\n\n      options = Object.assign({}, options, {\n        wireProtocolCommand: false\n      }); // Debug log\n\n      if (this.s.logger.isDebug()) {\n        this.s.logger.debug(\"executing command [\".concat(JSON.stringify({\n          ns: ns,\n          cmd: cmd,\n          options: debugOptions(DEBUG_FIELDS, options)\n        }), \"] against \").concat(this.name));\n      } // error if collation not supported\n\n\n      if (collationNotSupported(this, cmd)) {\n        callback(new MongoError(\"server \".concat(this.name, \" does not support collation\")));\n        return;\n      }\n\n      this.s.pool.withConnection(function (err, conn, cb) {\n        if (err) {\n          markServerUnknown(_this3, err);\n          return cb(err);\n        }\n\n        conn.command(ns, cmd, options, makeOperationHandler(_this3, options, cb));\n      }, callback);\n    }\n    /**\n     * Execute a query against the server\n     *\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {object} cmd The command document for the query\n     * @param {object} options Optional settings\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(ns, cmd, cursorState, options, callback) {\n      var _this4 = this;\n\n      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n        callback(new MongoError('server is closed'));\n        return;\n      }\n\n      this.s.pool.withConnection(function (err, conn, cb) {\n        if (err) {\n          markServerUnknown(_this4, err);\n          return cb(err);\n        }\n\n        conn.query(ns, cmd, cursorState, options, makeOperationHandler(_this4, options, cb));\n      }, callback);\n    }\n    /**\n     * Execute a `getMore` against the server\n     *\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {object} cursorState State data associated with the cursor calling this method\n     * @param {object} options Optional settings\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"getMore\",\n    value: function getMore(ns, cursorState, batchSize, options, callback) {\n      var _this5 = this;\n\n      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n        callback(new MongoError('server is closed'));\n        return;\n      }\n\n      this.s.pool.withConnection(function (err, conn, cb) {\n        if (err) {\n          markServerUnknown(_this5, err);\n          return cb(err);\n        }\n\n        conn.getMore(ns, cursorState, batchSize, options, makeOperationHandler(_this5, options, cb));\n      }, callback);\n    }\n    /**\n     * Execute a `killCursors` command against the server\n     *\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {object} cursorState State data associated with the cursor calling this method\n     * @param {function} callback\n     */\n\n  }, {\n    key: \"killCursors\",\n    value: function killCursors(ns, cursorState, callback) {\n      var _this6 = this;\n\n      if (this.s.state === STATE_CLOSING || this.s.state === STATE_CLOSED) {\n        if (typeof callback === 'function') {\n          callback(new MongoError('server is closed'));\n        }\n\n        return;\n      }\n\n      this.s.pool.withConnection(function (err, conn, cb) {\n        if (err) {\n          markServerUnknown(_this6, err);\n          return cb(err);\n        }\n\n        conn.killCursors(ns, cursorState, makeOperationHandler(_this6, null, cb));\n      }, callback);\n    }\n    /**\n     * Insert one or more documents\n     * @method\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {array} ops An array of documents to insert\n     * @param {boolean} [options.ordered=true] Execute in order or out of order\n     * @param {object} [options.writeConcern={}] Write concern for the operation\n     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n     * @param {ClientSession} [options.session] Session to use for the operation\n     * @param {opResultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(ns, ops, options, callback) {\n      executeWriteOperation({\n        server: this,\n        op: 'insert',\n        ns: ns,\n        ops: ops\n      }, options, callback);\n    }\n    /**\n     * Perform one or more update operations\n     * @method\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {array} ops An array of updates\n     * @param {boolean} [options.ordered=true] Execute in order or out of order\n     * @param {object} [options.writeConcern={}] Write concern for the operation\n     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n     * @param {ClientSession} [options.session] Session to use for the operation\n     * @param {opResultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(ns, ops, options, callback) {\n      executeWriteOperation({\n        server: this,\n        op: 'update',\n        ns: ns,\n        ops: ops\n      }, options, callback);\n    }\n    /**\n     * Perform one or more remove operations\n     * @method\n     * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n     * @param {array} ops An array of removes\n     * @param {boolean} [options.ordered=true] Execute in order or out of order\n     * @param {object} [options.writeConcern={}] Write concern for the operation\n     * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n     * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n     * @param {ClientSession} [options.session] Session to use for the operation\n     * @param {opResultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(ns, ops, options, callback) {\n      executeWriteOperation({\n        server: this,\n        op: 'remove',\n        ns: ns,\n        ops: ops\n      }, options, callback);\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      return this.s.description;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.s.description.address;\n    }\n  }, {\n    key: \"autoEncrypter\",\n    get: function get() {\n      if (this.s.options && this.s.options.autoEncrypter) {\n        return this.s.options.autoEncrypter;\n      }\n\n      return null;\n    }\n  }]);\n\n  return Server;\n}(EventEmitter);\n\nObject.defineProperty(Server.prototype, 'clusterTime', {\n  get: function get() {\n    return this.s.topology.clusterTime;\n  },\n  set: function set(clusterTime) {\n    this.s.topology.clusterTime = clusterTime;\n  }\n});\n\nfunction calculateRoundTripTime(oldRtt, duration) {\n  var alpha = 0.2;\n  return alpha * duration + (1 - alpha) * oldRtt;\n}\n\nfunction basicReadValidations(server, options) {\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    return new MongoError('readPreference must be an instance of ReadPreference');\n  }\n}\n\nfunction executeWriteOperation(args, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // TODO: once we drop Node 4, use destructuring either here or in arguments.\n\n  var server = args.server;\n  var op = args.op;\n  var ns = args.ns;\n  var ops = Array.isArray(args.ops) ? args.ops : [args.ops];\n\n  if (server.s.state === STATE_CLOSING || server.s.state === STATE_CLOSED) {\n    callback(new MongoError('server is closed'));\n    return;\n  }\n\n  if (collationNotSupported(server, options)) {\n    callback(new MongoError(\"server \".concat(server.name, \" does not support collation\")));\n    return;\n  }\n\n  server.s.pool.withConnection(function (err, conn, cb) {\n    if (err) {\n      markServerUnknown(server, err);\n      return cb(err);\n    }\n\n    conn[op](ns, ops, options, makeOperationHandler(server, options, cb));\n  }, callback);\n}\n\nfunction markServerUnknown(server, error) {\n  server.emit('descriptionReceived', new ServerDescription(server.description.address, null, {\n    error: error\n  }));\n}\n\nfunction makeOperationHandler(server, options, callback) {\n  return function handleOperationResult(err, result) {\n    if (err) {\n      if (err instanceof MongoNetworkError) {\n        if (options && options.session) {\n          options.session.serverSession.isDirty = true;\n        }\n\n        if (!isNetworkTimeoutError(err)) {\n          markServerUnknown(server, err);\n          server.s.pool.clear();\n        }\n      } else if (isSDAMUnrecoverableError(err)) {\n        if (maxWireVersion(server) <= 7 || isNodeShuttingDownError(err)) {\n          server.s.pool.clear();\n        }\n\n        markServerUnknown(server, err);\n        process.nextTick(function () {\n          return server.requestCheck();\n        });\n      }\n    }\n\n    callback(err, result);\n  };\n}\n\nmodule.exports = {\n  Server: Server\n};","map":null,"metadata":{},"sourceType":"script"}