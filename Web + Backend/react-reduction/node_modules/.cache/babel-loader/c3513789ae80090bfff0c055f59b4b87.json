{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar Logger = require('./connection/logger');\n\nvar retrieveBSON = require('./connection/utils').retrieveBSON;\n\nvar MongoError = require('./error').MongoError;\n\nvar MongoNetworkError = require('./error').MongoNetworkError;\n\nvar mongoErrorContextSymbol = require('./error').mongoErrorContextSymbol;\n\nvar collationNotSupported = require('./utils').collationNotSupported;\n\nvar ReadPreference = require('./topologies/read_preference');\n\nvar isUnifiedTopology = require('./utils').isUnifiedTopology;\n\nvar executeOperation = require('../operations/execute_operation');\n\nvar Readable = require('stream').Readable;\n\nvar SUPPORTS = require('../utils').SUPPORTS;\n\nvar MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nvar OperationBase = require('../operations/operation').OperationBase;\n\nvar BSON = retrieveBSON();\nvar Long = BSON.Long; // Possible states for a cursor\n\nvar CursorState = {\n  INIT: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  GET_MORE: 3\n}; //\n// Handle callback (including any exceptions thrown)\n\nfunction handleCallback(callback, err, result) {\n  try {\n    callback(err, result);\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n  }\n}\n/**\n * This is a cursor results callback\n *\n * @callback resultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {object} document\n */\n\n/**\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query.\n *\n * **CURSORS Cannot directly be instantiated**\n */\n\n/**\n * The core cursor class. All cursors in the driver build off of this one.\n *\n * @property {number} cursorBatchSize The current cursorBatchSize for the cursor\n * @property {number} cursorLimit The current cursorLimit for the cursor\n * @property {number} cursorSkip The current cursorSkip for the cursor\n */\n\n\nvar CoreCursor = /*#__PURE__*/function (_Readable) {\n  _inherits(CoreCursor, _Readable);\n\n  /**\n   * Create a new core `Cursor` instance.\n   * **NOTE** Not to be instantiated directly\n   *\n   * @param {object} topology The server topology instance.\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n   * @param {{object}|Long} cmd The selector (can be a command or a cursorId)\n   * @param {object} [options=null] Optional settings.\n   * @param {object} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/| find command documentation} and {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n   * @param {array} [options.documents=[]] Initial documents list for cursor\n   * @param {object} [options.transforms=null] Transform methods for the cursor results\n   * @param {function} [options.transforms.query] Transform the value returned from the initial query\n   * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype._next\n   */\n  function CoreCursor(topology, ns, cmd, options) {\n    var _this;\n\n    _classCallCheck(this, CoreCursor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CoreCursor).call(this, {\n      objectMode: true\n    }));\n    options = options || {};\n\n    if (ns instanceof OperationBase) {\n      _this.operation = ns;\n      ns = _this.operation.ns.toString();\n      options = _this.operation.options;\n      cmd = _this.operation.cmd ? _this.operation.cmd : {};\n    } // Cursor pool\n\n\n    _this.pool = null; // Cursor server\n\n    _this.server = null; // Do we have a not connected handler\n\n    _this.disconnectHandler = options.disconnectHandler; // Set local values\n\n    _this.bson = topology.s.bson;\n    _this.ns = ns;\n    _this.namespace = MongoDBNamespace.fromString(ns);\n    _this.cmd = cmd;\n    _this.options = options;\n    _this.topology = topology; // All internal state\n\n    _this.cursorState = {\n      cursorId: null,\n      cmd: cmd,\n      documents: options.documents || [],\n      cursorIndex: 0,\n      dead: false,\n      killed: false,\n      init: false,\n      notified: false,\n      limit: options.limit || cmd.limit || 0,\n      skip: options.skip || cmd.skip || 0,\n      batchSize: options.batchSize || cmd.batchSize || 1000,\n      currentLimit: 0,\n      // Result field name if not a cursor (contains the array of results)\n      transforms: options.transforms,\n      raw: options.raw || cmd && cmd.raw\n    };\n\n    if (typeof options.session === 'object') {\n      _this.cursorState.session = options.session;\n    } // Add promoteLong to cursor state\n\n\n    var topologyOptions = topology.s.options;\n\n    if (typeof topologyOptions.promoteLongs === 'boolean') {\n      _this.cursorState.promoteLongs = topologyOptions.promoteLongs;\n    } else if (typeof options.promoteLongs === 'boolean') {\n      _this.cursorState.promoteLongs = options.promoteLongs;\n    } // Add promoteValues to cursor state\n\n\n    if (typeof topologyOptions.promoteValues === 'boolean') {\n      _this.cursorState.promoteValues = topologyOptions.promoteValues;\n    } else if (typeof options.promoteValues === 'boolean') {\n      _this.cursorState.promoteValues = options.promoteValues;\n    } // Add promoteBuffers to cursor state\n\n\n    if (typeof topologyOptions.promoteBuffers === 'boolean') {\n      _this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;\n    } else if (typeof options.promoteBuffers === 'boolean') {\n      _this.cursorState.promoteBuffers = options.promoteBuffers;\n    }\n\n    if (topologyOptions.reconnect) {\n      _this.cursorState.reconnect = topologyOptions.reconnect;\n    } // Logger\n\n\n    _this.logger = Logger('Cursor', topologyOptions); //\n    // Did we pass in a cursor id\n\n    if (typeof cmd === 'number') {\n      _this.cursorState.cursorId = Long.fromNumber(cmd);\n      _this.cursorState.lastCursorId = _this.cursorState.cursorId;\n    } else if (cmd instanceof Long) {\n      _this.cursorState.cursorId = cmd;\n      _this.cursorState.lastCursorId = cmd;\n    } // TODO: remove as part of NODE-2104\n\n\n    if (_this.operation) {\n      _this.operation.cursorState = _this.cursorState;\n    }\n\n    return _this;\n  }\n\n  _createClass(CoreCursor, [{\n    key: \"setCursorBatchSize\",\n    value: function setCursorBatchSize(value) {\n      this.cursorState.batchSize = value;\n    }\n  }, {\n    key: \"cursorBatchSize\",\n    value: function cursorBatchSize() {\n      return this.cursorState.batchSize;\n    }\n  }, {\n    key: \"setCursorLimit\",\n    value: function setCursorLimit(value) {\n      this.cursorState.limit = value;\n    }\n  }, {\n    key: \"cursorLimit\",\n    value: function cursorLimit() {\n      return this.cursorState.limit;\n    }\n  }, {\n    key: \"setCursorSkip\",\n    value: function setCursorSkip(value) {\n      this.cursorState.skip = value;\n    }\n  }, {\n    key: \"cursorSkip\",\n    value: function cursorSkip() {\n      return this.cursorState.skip;\n    }\n    /**\n     * Retrieve the next document from the cursor\n     * @method\n     * @param {resultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"_next\",\n    value: function _next(callback) {\n      nextFunction(this, callback);\n    }\n    /**\n     * Clone the cursor\n     * @method\n     * @return {Cursor}\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this.topology.cursor(this.ns, this.cmd, this.options);\n    }\n    /**\n     * Checks if the cursor is dead\n     * @method\n     * @return {boolean} A boolean signifying if the cursor is dead or not\n     */\n\n  }, {\n    key: \"isDead\",\n    value: function isDead() {\n      return this.cursorState.dead === true;\n    }\n    /**\n     * Checks if the cursor was killed by the application\n     * @method\n     * @return {boolean} A boolean signifying if the cursor was killed by the application\n     */\n\n  }, {\n    key: \"isKilled\",\n    value: function isKilled() {\n      return this.cursorState.killed === true;\n    }\n    /**\n     * Checks if the cursor notified it's caller about it's death\n     * @method\n     * @return {boolean} A boolean signifying if the cursor notified the callback\n     */\n\n  }, {\n    key: \"isNotified\",\n    value: function isNotified() {\n      return this.cursorState.notified === true;\n    }\n    /**\n     * Returns current buffered documents length\n     * @method\n     * @return {number} The number of items in the buffered documents\n     */\n\n  }, {\n    key: \"bufferedCount\",\n    value: function bufferedCount() {\n      return this.cursorState.documents.length - this.cursorState.cursorIndex;\n    }\n    /**\n     * Returns current buffered documents\n     * @method\n     * @return {Array} An array of buffered documents\n     */\n\n  }, {\n    key: \"readBufferedDocuments\",\n    value: function readBufferedDocuments(number) {\n      var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;\n      var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;\n      var elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length); // Transform the doc with passed in transformation method if provided\n\n      if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') {\n        // Transform all the elements\n        for (var i = 0; i < elements.length; i++) {\n          elements[i] = this.cursorState.transforms.doc(elements[i]);\n        }\n      } // Ensure we do not return any more documents than the limit imposed\n      // Just return the number of elements up to the limit\n\n\n      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {\n        elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);\n        this.kill();\n      } // Adjust current limit\n\n\n      this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;\n      this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length; // Return elements\n\n      return elements;\n    }\n    /**\n     * Resets local state for this cursor instance, and issues a `killCursors` command to the server\n     *\n     * @param {resultCallback} callback A callback function\n     */\n\n  }, {\n    key: \"kill\",\n    value: function kill(callback) {\n      // Set cursor to dead\n      this.cursorState.dead = true;\n      this.cursorState.killed = true; // Remove documents\n\n      this.cursorState.documents = []; // If no cursor id just return\n\n      if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {\n        if (callback) callback(null, null);\n        return;\n      }\n\n      this.server.killCursors(this.ns, this.cursorState, callback);\n    }\n    /**\n     * Resets the cursor\n     */\n\n  }, {\n    key: \"rewind\",\n    value: function rewind() {\n      if (this.cursorState.init) {\n        if (!this.cursorState.dead) {\n          this.kill();\n        }\n\n        this.cursorState.currentLimit = 0;\n        this.cursorState.init = false;\n        this.cursorState.dead = false;\n        this.cursorState.killed = false;\n        this.cursorState.notified = false;\n        this.cursorState.documents = [];\n        this.cursorState.cursorId = null;\n        this.cursorState.cursorIndex = 0;\n      }\n    } // Internal methods\n\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      var _this2 = this;\n\n      if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {\n        return this.push(null);\n      } // Get the next item\n\n\n      this._next(function (err, result) {\n        if (err) {\n          if (_this2.listeners('error') && _this2.listeners('error').length > 0) {\n            _this2.emit('error', err);\n          }\n\n          if (!_this2.isDead()) _this2.close(); // Emit end event\n\n          _this2.emit('end');\n\n          return _this2.emit('finish');\n        } // If we provided a transformation method\n\n\n        if (_this2.cursorState.streamOptions && typeof _this2.cursorState.streamOptions.transform === 'function' && result != null) {\n          return _this2.push(_this2.cursorState.streamOptions.transform(result));\n        } // If we provided a map function\n\n\n        if (_this2.cursorState.transforms && typeof _this2.cursorState.transforms.doc === 'function' && result != null) {\n          return _this2.push(_this2.cursorState.transforms.doc(result));\n        } // Return the result\n\n\n        _this2.push(result);\n\n        if (result === null && _this2.isDead()) {\n          _this2.once('end', function () {\n            _this2.close();\n\n            _this2.emit('finish');\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_endSession\",\n    value: function _endSession(options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      var session = this.cursorState.session;\n\n      if (session && (options.force || session.owner === this)) {\n        this.cursorState.session = undefined;\n\n        if (this.operation) {\n          this.operation.clearSession();\n        }\n\n        session.endSession(callback);\n        return true;\n      }\n\n      if (callback) {\n        callback();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_getMore\",\n    value: function _getMore(callback) {\n      if (this.logger.isDebug()) {\n        this.logger.debug(\"schedule getMore call for query [\".concat(JSON.stringify(this.query), \"]\"));\n      } // Set the current batchSize\n\n\n      var batchSize = this.cursorState.batchSize;\n\n      if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {\n        batchSize = this.cursorState.limit - this.cursorState.currentLimit;\n      }\n\n      this.server.getMore(this.ns, this.cursorState, batchSize, this.options, callback);\n    }\n  }, {\n    key: \"_initializeCursor\",\n    value: function _initializeCursor(callback) {\n      var _this3 = this;\n\n      var cursor = this; // NOTE: this goes away once cursors use `executeOperation`\n\n      if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {\n        cursor.topology.selectServer(ReadPreference.primaryPreferred, function (err) {\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          _this3._initializeCursor(callback);\n        });\n        return;\n      }\n\n      function done(err, result) {\n        if (cursor.cursorState.cursorId && cursor.cursorState.cursorId.isZero() && cursor._endSession) {\n          cursor._endSession();\n        }\n\n        if (cursor.cursorState.documents.length === 0 && cursor.cursorState.cursorId && cursor.cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {\n          return setCursorNotified(cursor, callback);\n        }\n\n        callback(err, result);\n      }\n\n      var queryCallback = function queryCallback(err, r) {\n        if (err) {\n          return done(err);\n        }\n\n        var result = r.message;\n\n        if (result.queryFailure) {\n          return done(new MongoError(result.documents[0]), null);\n        } // Check if we have a command cursor\n\n\n        if (Array.isArray(result.documents) && result.documents.length === 1 && (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) && (typeof result.documents[0].cursor !== 'string' || result.documents[0]['$err'] || result.documents[0]['errmsg'] || Array.isArray(result.documents[0].result))) {\n          // We have an error document, return the error\n          if (result.documents[0]['$err'] || result.documents[0]['errmsg']) {\n            return done(new MongoError(result.documents[0]), null);\n          } // We have a cursor document\n\n\n          if (result.documents[0].cursor != null && typeof result.documents[0].cursor !== 'string') {\n            var id = result.documents[0].cursor.id; // If we have a namespace change set the new namespace for getmores\n\n            if (result.documents[0].cursor.ns) {\n              cursor.ns = result.documents[0].cursor.ns;\n            } // Promote id to long if needed\n\n\n            cursor.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;\n            cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;\n            cursor.cursorState.operationTime = result.documents[0].operationTime; // If we have a firstBatch set it\n\n            if (Array.isArray(result.documents[0].cursor.firstBatch)) {\n              cursor.cursorState.documents = result.documents[0].cursor.firstBatch; //.reverse();\n            } // Return after processing command cursor\n\n\n            return done(null, result);\n          }\n\n          if (Array.isArray(result.documents[0].result)) {\n            cursor.cursorState.documents = result.documents[0].result;\n            cursor.cursorState.cursorId = Long.ZERO;\n            return done(null, result);\n          }\n        } // Otherwise fall back to regular find path\n\n\n        var cursorId = result.cursorId || 0;\n        cursor.cursorState.cursorId = cursorId instanceof Long ? cursorId : Long.fromNumber(cursorId);\n        cursor.cursorState.documents = result.documents;\n        cursor.cursorState.lastCursorId = result.cursorId; // Transform the results with passed in transformation method if provided\n\n        if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === 'function') {\n          cursor.cursorState.documents = cursor.cursorState.transforms.query(result);\n        }\n\n        done(null, result);\n      };\n\n      if (cursor.operation) {\n        if (cursor.logger.isDebug()) {\n          cursor.logger.debug(\"issue initial query [\".concat(JSON.stringify(cursor.cmd), \"] with flags [\").concat(JSON.stringify(cursor.query), \"]\"));\n        }\n\n        executeOperation(cursor.topology, cursor.operation, function (err, result) {\n          if (err) {\n            done(err);\n            return;\n          }\n\n          cursor.server = cursor.operation.server;\n          cursor.cursorState.init = true; // NOTE: this is a special internal method for cloning a cursor, consider removing\n\n          if (cursor.cursorState.cursorId != null) {\n            return done();\n          }\n\n          queryCallback(err, result);\n        });\n        return;\n      } // Very explicitly choose what is passed to selectServer\n\n\n      var serverSelectOptions = {};\n\n      if (cursor.cursorState.session) {\n        serverSelectOptions.session = cursor.cursorState.session;\n      }\n\n      if (cursor.operation) {\n        serverSelectOptions.readPreference = cursor.operation.readPreference;\n      } else if (cursor.options.readPreference) {\n        serverSelectOptions.readPreference = cursor.options.readPreference;\n      }\n\n      return cursor.topology.selectServer(serverSelectOptions, function (err, server) {\n        if (err) {\n          var disconnectHandler = cursor.disconnectHandler;\n\n          if (disconnectHandler != null) {\n            return disconnectHandler.addObjectAndMethod('cursor', cursor, 'next', [callback], callback);\n          }\n\n          return callback(err);\n        }\n\n        cursor.server = server;\n        cursor.cursorState.init = true;\n\n        if (collationNotSupported(cursor.server, cursor.cmd)) {\n          return callback(new MongoError(\"server \".concat(cursor.server.name, \" does not support collation\")));\n        } // NOTE: this is a special internal method for cloning a cursor, consider removing\n\n\n        if (cursor.cursorState.cursorId != null) {\n          return done();\n        }\n\n        if (cursor.logger.isDebug()) {\n          cursor.logger.debug(\"issue initial query [\".concat(JSON.stringify(cursor.cmd), \"] with flags [\").concat(JSON.stringify(cursor.query), \"]\"));\n        }\n\n        if (cursor.cmd.find != null) {\n          server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);\n          return;\n        }\n\n        var commandOptions = Object.assign({\n          session: cursor.cursorState.session\n        }, cursor.options);\n        server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);\n      });\n    }\n  }]);\n\n  return CoreCursor;\n}(Readable);\n\nif (SUPPORTS.ASYNC_ITERATOR) {\n  CoreCursor.prototype[Symbol.asyncIterator] = require('../async/async_iterator').asyncIterator;\n}\n/**\n * Validate if the pool is dead and return error\n */\n\n\nfunction isConnectionDead(self, callback) {\n  if (self.pool && self.pool.isDestroyed()) {\n    self.cursorState.killed = true;\n    var err = new MongoNetworkError(\"connection to host \".concat(self.pool.host, \":\").concat(self.pool.port, \" was destroyed\"));\n\n    _setCursorNotifiedImpl(self, function () {\n      return callback(err);\n    });\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Validate if the cursor is dead but was not explicitly killed by user\n */\n\n\nfunction isCursorDeadButNotkilled(self, callback) {\n  // Cursor is dead but not marked killed, return null\n  if (self.cursorState.dead && !self.cursorState.killed) {\n    self.cursorState.killed = true;\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Validate if the cursor is dead and was killed by user\n */\n\n\nfunction isCursorDeadAndKilled(self, callback) {\n  if (self.cursorState.dead && self.cursorState.killed) {\n    handleCallback(callback, new MongoError('cursor is dead'));\n    return true;\n  }\n\n  return false;\n}\n/**\n * Validate if the cursor was killed by the user\n */\n\n\nfunction isCursorKilled(self, callback) {\n  if (self.cursorState.killed) {\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Mark cursor as being dead and notified\n */\n\n\nfunction setCursorDeadAndNotified(self, callback) {\n  self.cursorState.dead = true;\n  setCursorNotified(self, callback);\n}\n/**\n * Mark cursor as being notified\n */\n\n\nfunction setCursorNotified(self, callback) {\n  _setCursorNotifiedImpl(self, function () {\n    return handleCallback(callback, null, null);\n  });\n}\n\nfunction _setCursorNotifiedImpl(self, callback) {\n  self.cursorState.notified = true;\n  self.cursorState.documents = [];\n  self.cursorState.cursorIndex = 0;\n\n  if (self._endSession) {\n    self._endSession(undefined, function () {\n      return callback();\n    });\n\n    return;\n  }\n\n  return callback();\n}\n\nfunction nextFunction(self, callback) {\n  // We have notified about it\n  if (self.cursorState.notified) {\n    return callback(new Error('cursor is exhausted'));\n  } // Cursor is killed return null\n\n\n  if (isCursorKilled(self, callback)) return; // Cursor is dead but not marked killed, return null\n\n  if (isCursorDeadButNotkilled(self, callback)) return; // We have a dead and killed cursor, attempting to call next should error\n\n  if (isCursorDeadAndKilled(self, callback)) return; // We have just started the cursor\n\n  if (!self.cursorState.init) {\n    // Topology is not connected, save the call in the provided store to be\n    // Executed at some point when the handler deems it's reconnected\n    if (!self.topology.isConnected(self.options)) {\n      // Only need this for single server, because repl sets and mongos\n      // will always continue trying to reconnect\n      if (self.topology._type === 'server' && !self.topology.s.options.reconnect) {\n        // Reconnect is disabled, so we'll never reconnect\n        return callback(new MongoError('no connection available'));\n      }\n\n      if (self.disconnectHandler != null) {\n        if (self.topology.isDestroyed()) {\n          // Topology was destroyed, so don't try to wait for it to reconnect\n          return callback(new MongoError('Topology was destroyed'));\n        }\n\n        self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\n        return;\n      }\n    }\n\n    self._initializeCursor(function (err, result) {\n      if (err || result === null) {\n        callback(err, result);\n        return;\n      }\n\n      nextFunction(self, callback);\n    });\n\n    return;\n  }\n\n  if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n    // Ensure we kill the cursor on the server\n    self.kill(); // Set cursor in dead and notified state\n\n    return setCursorDeadAndNotified(self, callback);\n  } else if (self.cursorState.cursorIndex === self.cursorState.documents.length && !Long.ZERO.equals(self.cursorState.cursorId)) {\n    // Ensure an empty cursor state\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0; // Check if topology is destroyed\n\n    if (self.topology.isDestroyed()) return callback(new MongoNetworkError('connection destroyed, not possible to instantiate cursor')); // Check if connection is dead and return if not possible to\n    // execute a getMore on this connection\n\n    if (isConnectionDead(self, callback)) return; // Execute the next get more\n\n    self._getMore(function (err, doc, connection) {\n      if (err) {\n        if (err instanceof MongoError) {\n          err[mongoErrorContextSymbol].isGetMore = true;\n        }\n\n        return handleCallback(callback, err);\n      }\n\n      if (self.cursorState.cursorId && self.cursorState.cursorId.isZero() && self._endSession) {\n        self._endSession();\n      } // Save the returned connection to ensure all getMore's fire over the same connection\n\n\n      self.connection = connection; // Tailable cursor getMore result, notify owner about it\n      // No attempt is made here to retry, this is left to the user of the\n      // core module to handle to keep core simple\n\n      if (self.cursorState.documents.length === 0 && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n        // No more documents in the tailed cursor\n        return handleCallback(callback, new MongoError({\n          message: 'No more documents in tailed cursor',\n          tailable: self.cmd.tailable,\n          awaitData: self.cmd.awaitData\n        }));\n      } else if (self.cursorState.documents.length === 0 && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) {\n        return nextFunction(self, callback);\n      }\n\n      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n        return setCursorDeadAndNotified(self, callback);\n      }\n\n      nextFunction(self, callback);\n    });\n  } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n    return handleCallback(callback, new MongoError({\n      message: 'No more documents in tailed cursor',\n      tailable: self.cmd.tailable,\n      awaitData: self.cmd.awaitData\n    }));\n  } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && Long.ZERO.equals(self.cursorState.cursorId)) {\n    setCursorDeadAndNotified(self, callback);\n  } else {\n    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n      // Ensure we kill the cursor on the server\n      self.kill(); // Set cursor in dead and notified state\n\n      return setCursorDeadAndNotified(self, callback);\n    } // Increment the current cursor limit\n\n\n    self.cursorState.currentLimit += 1; // Get the document\n\n    var doc = self.cursorState.documents[self.cursorState.cursorIndex++]; // Doc overflow\n\n    if (!doc || doc.$err) {\n      // Ensure we kill the cursor on the server\n      self.kill(); // Set cursor in dead and notified state\n\n      return setCursorDeadAndNotified(self, function () {\n        handleCallback(callback, new MongoError(doc ? doc.$err : undefined));\n      });\n    } // Transform the doc with passed in transformation method if provided\n\n\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') {\n      doc = self.cursorState.transforms.doc(doc);\n    } // Return the document\n\n\n    handleCallback(callback, null, doc);\n  }\n}\n\nmodule.exports = {\n  CursorState: CursorState,\n  CoreCursor: CoreCursor\n};","map":null,"metadata":{},"sourceType":"script"}