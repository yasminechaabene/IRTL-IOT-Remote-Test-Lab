{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\yosrj\\\\Desktop\\\\IOT_Lab\\\\react-reduction\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar CServer = require('../core').Server;\n\nvar Cursor = require('../cursor');\n\nvar TopologyBase = require('./topology_base').TopologyBase;\n\nvar Store = require('./topology_base').Store;\n\nvar MongoError = require('../core').MongoError;\n\nvar MAX_JS_INT = require('../utils').MAX_JS_INT;\n\nvar translateOptions = require('../utils').translateOptions;\n\nvar filterOptions = require('../utils').filterOptions;\n\nvar mergeOptions = require('../utils').mergeOptions;\n/**\n * @fileOverview The **Server** class is a class that represents a single server topology and is\n * used to construct connections.\n *\n * **Server Should not be used, use MongoClient.connect**\n */\n// Allowed parameters\n\n\nvar legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'sslCA', 'sslCRL', 'sslCert', 'ciphers', 'ecdhCurve', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries', 'store', 'auto_reconnect', 'autoReconnect', 'emitError', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'family', 'loggerLevel', 'logger', 'reconnectTries', 'reconnectInterval', 'monitoring', 'appname', 'domainsEnabled', 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'compression', 'promiseLibrary', 'monitorCommands'];\n/**\n * Creates a new Server instance\n * @class\n * @deprecated\n * @param {string} host The host for the server, can be either an IP4, IP6 or domain socket style host.\n * @param {number} [port] The server port if IP4.\n * @param {object} [options] Optional settings.\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\n * @param {boolean} [options.sslValidate=false] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {array} [options.sslCA] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {array} [options.sslCRL] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslCert] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.ciphers] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {string} [options.ecdhCurve] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\n * @param {(Buffer|string)} [options.sslKey] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {(Buffer|string)} [options.sslPass] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\n * @param {string} [options.servername] String containing the server name requested via TLS SNI.\n * @param {object} [options.socketOptions] Socket options\n * @param {boolean} [options.socketOptions.autoReconnect=true] Reconnect on error.\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\n * @param {boolean} [options.socketOptions.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.socketOptions.keepAliveInitialDelay=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket\n * @param {number} [options.socketOptions.connectTimeoutMS=10000] How long to wait for a connection to be established before timing out\n * @param {number} [options.socketOptions.socketTimeoutMS=360000] How long a send or receive on a socket can take before timing out\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.monitoring=true] Triggers the server instance to call ismaster\n * @param {number} [options.haInterval=10000] The interval of calling ismaster when monitoring is enabled.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n * @fires Server#commandStarted\n * @fires Server#commandSucceeded\n * @fires Server#commandFailed\n * @property {string} parserType the parser type used (c++ or js).\n * @return {Server} a Server instance.\n */\n\nvar Server = /*#__PURE__*/function (_TopologyBase) {\n  _inherits(Server, _TopologyBase);\n\n  function Server(host, port, options) {\n    var _this;\n\n    _classCallCheck(this, Server);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Server).call(this));\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this)); // Filter the options\n\n\n    options = filterOptions(options, legalOptionNames); // Promise library\n\n    var promiseLibrary = options.promiseLibrary; // Stored options\n\n    var storeOptions = {\n      force: false,\n      bufferMaxEntries: typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : MAX_JS_INT\n    }; // Shared global store\n\n    var store = options.store || new Store(self, storeOptions); // Detect if we have a socket connection\n\n    if (host.indexOf('/') !== -1) {\n      if (port != null && typeof port === 'object') {\n        options = port;\n        port = null;\n      }\n    } else if (port == null) {\n      throw MongoError.create({\n        message: 'port must be specified',\n        driver: true\n      });\n    } // Get the reconnect option\n\n\n    var reconnect = typeof options.auto_reconnect === 'boolean' ? options.auto_reconnect : true;\n    reconnect = typeof options.autoReconnect === 'boolean' ? options.autoReconnect : reconnect; // Clone options\n\n    var clonedOptions = mergeOptions({}, {\n      host: host,\n      port: port,\n      disconnectHandler: store,\n      cursorFactory: Cursor,\n      reconnect: reconnect,\n      emitError: typeof options.emitError === 'boolean' ? options.emitError : true,\n      size: typeof options.poolSize === 'number' ? options.poolSize : 5,\n      monitorCommands: typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false\n    }); // Translate any SSL options and other connectivity options\n\n    clonedOptions = translateOptions(clonedOptions, options); // Socket options\n\n    var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options; // Translate all the options to the core types\n\n    clonedOptions = translateOptions(clonedOptions, socketOptions); // Define the internal properties\n\n    _this.s = {\n      // Create an instance of a server instance from core module\n      coreTopology: new CServer(clonedOptions),\n      // Server capabilities\n      sCapabilities: null,\n      // Cloned options\n      clonedOptions: clonedOptions,\n      // Reconnect\n      reconnect: clonedOptions.reconnect,\n      // Emit error\n      emitError: clonedOptions.emitError,\n      // Pool size\n      poolSize: clonedOptions.size,\n      // Store Options\n      storeOptions: storeOptions,\n      // Store\n      store: store,\n      // Host\n      host: host,\n      // Port\n      port: port,\n      // Options\n      options: options,\n      // Server Session Pool\n      sessionPool: null,\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: promiseLibrary || Promise\n    };\n    return _this;\n  } // Connect\n\n\n  _createClass(Server, [{\n    key: \"connect\",\n    value: function connect(_options, callback) {\n      var self = this;\n      if ('function' === typeof _options) callback = _options, _options = {};\n      if (_options == null) _options = this.s.clonedOptions;\n      if (!('function' === typeof callback)) callback = null;\n      _options = Object.assign({}, this.s.clonedOptions, _options);\n      self.s.options = _options; // Update bufferMaxEntries\n\n      self.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === 'number' ? _options.bufferMaxEntries : -1; // Error handler\n\n      var connectErrorHandler = function connectErrorHandler() {\n        return function (err) {\n          // Remove all event handlers\n          var events = ['timeout', 'error', 'close'];\n          events.forEach(function (e) {\n            self.s.coreTopology.removeListener(e, connectHandlers[e]);\n          });\n          self.s.coreTopology.removeListener('connect', connectErrorHandler); // Try to callback\n\n          try {\n            callback(err);\n          } catch (err) {\n            process.nextTick(function () {\n              throw err;\n            });\n          }\n        };\n      }; // Actual handler\n\n\n      var errorHandler = function errorHandler(event) {\n        return function (err) {\n          if (event !== 'error') {\n            self.emit(event, err);\n          }\n        };\n      }; // Error handler\n\n\n      var reconnectHandler = function reconnectHandler() {\n        self.emit('reconnect', self);\n        self.s.store.execute();\n      }; // Reconnect failed\n\n\n      var reconnectFailedHandler = function reconnectFailedHandler(err) {\n        self.emit('reconnectFailed', err);\n        self.s.store.flush(err);\n      }; // Destroy called on topology, perform cleanup\n\n\n      var destroyHandler = function destroyHandler() {\n        self.s.store.flush();\n      }; // relay the event\n\n\n      var relay = function relay(event) {\n        return function (t, server) {\n          self.emit(event, t, server);\n        };\n      }; // Connect handler\n\n\n      var connectHandler = function connectHandler() {\n        // Clear out all the current handlers left over\n        ['timeout', 'error', 'close', 'destroy'].forEach(function (e) {\n          self.s.coreTopology.removeAllListeners(e);\n        }); // Set up listeners\n\n        self.s.coreTopology.on('timeout', errorHandler('timeout'));\n        self.s.coreTopology.once('error', errorHandler('error'));\n        self.s.coreTopology.on('close', errorHandler('close')); // Only called on destroy\n\n        self.s.coreTopology.on('destroy', destroyHandler); // Emit open event\n\n        self.emit('open', null, self); // Return correctly\n\n        try {\n          callback(null, self);\n        } catch (err) {\n          process.nextTick(function () {\n            throw err;\n          });\n        }\n      }; // Set up listeners\n\n\n      var connectHandlers = {\n        timeout: connectErrorHandler('timeout'),\n        error: connectErrorHandler('error'),\n        close: connectErrorHandler('close')\n      }; // Clear out all the current handlers left over\n\n      ['timeout', 'error', 'close', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed'].forEach(function (e) {\n        self.s.coreTopology.removeAllListeners(e);\n      }); // Add the event handlers\n\n      self.s.coreTopology.once('timeout', connectHandlers.timeout);\n      self.s.coreTopology.once('error', connectHandlers.error);\n      self.s.coreTopology.once('close', connectHandlers.close);\n      self.s.coreTopology.once('connect', connectHandler); // Reconnect server\n\n      self.s.coreTopology.on('reconnect', reconnectHandler);\n      self.s.coreTopology.on('reconnectFailed', reconnectFailedHandler); // Set up SDAM listeners\n\n      self.s.coreTopology.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\n      self.s.coreTopology.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\n      self.s.coreTopology.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\n      self.s.coreTopology.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\n      self.s.coreTopology.on('serverOpening', relay('serverOpening'));\n      self.s.coreTopology.on('serverClosed', relay('serverClosed'));\n      self.s.coreTopology.on('topologyOpening', relay('topologyOpening'));\n      self.s.coreTopology.on('topologyClosed', relay('topologyClosed'));\n      self.s.coreTopology.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));\n      self.s.coreTopology.on('commandStarted', relay('commandStarted'));\n      self.s.coreTopology.on('commandSucceeded', relay('commandSucceeded'));\n      self.s.coreTopology.on('commandFailed', relay('commandFailed'));\n      self.s.coreTopology.on('attemptReconnect', relay('attemptReconnect'));\n      self.s.coreTopology.on('monitoring', relay('monitoring')); // Start connection\n\n      self.s.coreTopology.connect(_options);\n    }\n  }]);\n\n  return Server;\n}(TopologyBase);\n\nObject.defineProperty(Server.prototype, 'poolSize', {\n  enumerable: true,\n  get: function get() {\n    return this.s.coreTopology.connections().length;\n  }\n});\nObject.defineProperty(Server.prototype, 'autoReconnect', {\n  enumerable: true,\n  get: function get() {\n    return this.s.reconnect;\n  }\n});\nObject.defineProperty(Server.prototype, 'host', {\n  enumerable: true,\n  get: function get() {\n    return this.s.host;\n  }\n});\nObject.defineProperty(Server.prototype, 'port', {\n  enumerable: true,\n  get: function get() {\n    return this.s.port;\n  }\n});\n/**\n * Server connect event\n *\n * @event Server#connect\n * @type {object}\n */\n\n/**\n * Server close event\n *\n * @event Server#close\n * @type {object}\n */\n\n/**\n * Server reconnect event\n *\n * @event Server#reconnect\n * @type {object}\n */\n\n/**\n * Server error event\n *\n * @event Server#error\n * @type {MongoError}\n */\n\n/**\n * Server timeout event\n *\n * @event Server#timeout\n * @type {object}\n */\n\n/**\n * Server parseError event\n *\n * @event Server#parseError\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command was started, if command monitoring is enabled\n *\n * @event Server#commandStarted\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command succeeded, if command monitoring is enabled\n *\n * @event Server#commandSucceeded\n * @type {object}\n */\n\n/**\n * An event emitted indicating a command failed, if command monitoring is enabled\n *\n * @event Server#commandFailed\n * @type {object}\n */\n\nmodule.exports = Server;","map":null,"metadata":{},"sourceType":"script"}